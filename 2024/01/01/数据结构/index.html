<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="caijiQAQ">
    
    <title>
        
            数据结构 |
        
        学习笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"caiji-qaq.github.io","root":"/","language":"en"}
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"header_transparent":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":false,"preload":false},"code_copy":{},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":false,"min2read":false},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               学习笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">数据结构</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">caijiQAQ</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2024-01-01 09:28:41</span>
        <span class="mobile">2024-01-01 09:28</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2024-08-28 18:57:57</span>
    </span>
    
    
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="ACM模式输入"><a href="#ACM模式输入" class="headerlink" title="ACM模式输入"></a>ACM模式输入</h1><h2 id="1-输入数据转换为vector"><a href="#1-输入数据转换为vector" class="headerlink" title="1.输入数据转换为vector"></a>1.输入数据转换为vector</h2><ul>
<li><p>1.回车来结束这个输入整数的过程<br>别忘记引入sstream！同时istringstream iss(input)也很关键<br>&#x3D;&#x3D;getline+istringstream&#x3D;&#x3D;</p>
<pre><code>  #include &lt;iostream&gt;
  #include &lt;vector&gt;
  #include &lt;string&gt;
  #include &lt;sstream&gt;

  int main() &#123;
  std::vector&lt;int&gt; data_vector;
  std::string input;

  std::cout &lt;&lt; &quot;请输入一行用空格隔开的整数（按回车键结束）: &quot;;
  std::getline(std::cin, input);

  std::istringstream iss(input);
  int value;
  while (iss &gt;&gt; value) &#123;
          data_vector.push_back(value);
  &#125;

  std::cout &lt;&lt; &quot;输入的向量为: &quot;;
  for (int val : data_vector) &#123;
          std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;
  &#125;

  return 0;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="2-将int转string"><a href="#2-将int转string" class="headerlink" title="2.将int转string"></a>2.将int转string</h2><ul>
<li><p>通过to_string()函数转换</p>
<pre><code>  #include &lt;iostream&gt;

  int main()
  &#123;
  int num = 123;
  std::cout &lt;&lt; std::to_string(num);
  return 0;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="3-将string转为int"><a href="#3-将string转为int" class="headerlink" title="3.将string转为int"></a>3.将string转为int</h2><ul>
<li><p>通过stoi()将字符串转为int</p>
<pre><code>  #include &lt;iostream&gt;
  #include &lt;string&gt;

  int main() &#123;

  std::string str = &quot;123&quot;;
  int num;

  // 使用stoi()将str1的值存储到x
  num = std::stoi(str);

  std::cout &lt;&lt; num;

  return 0;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="4-想用sort的cmp的写法"><a href="#4-想用sort的cmp的写法" class="headerlink" title="4.想用sort的cmp的写法"></a>4.想用sort的cmp的写法</h2><p><strong>int的写法</strong></p>
<pre><code>sort(A.begin(), A.end(), cmp);  
static bool cmp(int a,int b)&#123;
    return abs(a)&gt;abs(b);
&#125;
</code></pre>
<h2 id="5-string的用法"><a href="#5-string的用法" class="headerlink" title="5.string的用法"></a>5.string的用法</h2><ul>
<li><p>1.拼接</p>
<pre><code>  string s = &quot;Hello, &quot;;  
  s += &quot;world!&quot;; // s 现在为 &quot;Hello, world!&quot;
</code></pre>
</li>
<li><p>2.比较<br>compare：</p>
<pre><code>  int result1 = str1.compare(str2); // str1 &lt; str2，返回负整数  
  int result2 = str1.compare(str3); // str1 == str3，返回0  
  int result3 = str1.compare(cstr); // str1 == cstr，返回0  
</code></pre>
</li>
<li><p>3.字符串子串<br>substr</p>
<pre><code>  std::string str = &quot;Hello, World!&quot;;  
  // 获取从索引0开始的5个字符的子串  
  std::string substr1 = str.substr(0, 5);  
  // 获取从索引7开始到字符串末尾的子串  
  std::string substr2 = str.substr(7);  
  std::cout &lt;&lt; &quot;Substring 2: &quot; &lt;&lt; substr2 &lt;&lt; std::endl; // 输出: Substring 2: World!
</code></pre>
</li>
</ul>
<h2 id="6-有点小好用之-string-x3D-gt-1-2-3-4-5-6-转为vector"><a href="#6-有点小好用之-string-x3D-gt-1-2-3-4-5-6-转为vector" class="headerlink" title="6.有点小好用之(string)&#x3D;&gt;[1,2,3,4,5,6]转为vector"></a>6.有点小好用之(string)&#x3D;&gt;[1,2,3,4,5,6]转为vector</h2><pre><code>    #include&lt;iostream&gt;
    #include&lt;vector&gt;
    #include&lt;sstream&gt;
    #include&lt;string&gt;
    using namespace std;

    int main()&#123;
    string s=&quot;[1,234,56,78]&quot;;
    s.erase(s.begin());
    s.erase(s.end()-1);
    cout&lt;&lt;s&lt;&lt;endl;
    string tmp;
    vector&lt;int&gt; nums;
    //将字符串转为字符串流，这样才能输入到getline中
    stringstream ss(s);
    while(getline(ss,tmp,&#39;,&#39;))&#123;
    nums.push_back(stoi(tmp));
    &#125;
    for(int i = 0;i&lt;nums.size();i++)&#123;
            cout&lt;&lt;nums[i]&lt;&lt;endl;
    &#125;
    &#125;
</code></pre>
<h1 id="1-C-哈希表"><a href="#1-C-哈希表" class="headerlink" title="1.C++哈希表"></a>1.C++哈希表</h1><p>leetcode:1</p>
<h2 id="哈希表概念"><a href="#哈希表概念" class="headerlink" title="哈希表概念"></a>哈希表概念</h2><p>“散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这<strong>加快了查找速度</strong>。这个映射函数称做散列函数，存放记录的数组称做散列。类似python里的字典。</p>
<p>哈希表一般使用两种方法：1.数组+链表 2.数组+二叉树</p>
<p><strong>散列函数</strong>：一个值经过一系列的变换变成了另一个值。</p>
<p><strong>哈希表</strong>就是通过将关键值也就是key通过一个散列函数加工处理之后得到一个值，这个值就是数据存放的位置，我们就可以根据这个值快速的找到我们想要的数据</p>
<p><strong>哈希冲突</strong>：经过哈希函数之后计算得到的一个值，结果这个值被另一个键值同样可以计算出来，导致数组中这个值1的位置两个内容会发生冲突。</p>
<p><strong>处理哈希冲突</strong></p>
<ul>
<li>1.开放寻址法<br>即这个位置被占了，重新寻找一个其他没被占的位置</li>
<li>2.拉链法<br>位置被占了，把这个位置延伸出去使用链表扩展这个数组的内容。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240217165504.png"></li>
</ul>
<p><strong>哈希表的查找</strong><br>比如我们现在要通过学号102011来查找学生的姓名，怎么操作呢？我们首先通过学号利用哈希函数得出位置1，然后我们就去位置1拿数据啊，拿到这个Entry之后我们得看看这个Entry的key是不是我们的学号102011，一看是101011，什么鬼，一边去，这不是我们要的key啊，然后根据这个Entry的next知道下一给位置，在比较key，好成功找到李四。</p>
<h2 id="unordered-map-这个容器使用的是哈希表实现的"><a href="#unordered-map-这个容器使用的是哈希表实现的" class="headerlink" title="unordered_map:这个容器使用的是哈希表实现的"></a>unordered_map:这个容器使用的是哈希表实现的</h2><p>unordered_map使用了哈希表的原理实现，其增删查改的时间复杂度都是O(1)，空间复杂度是O（n），适用于快速查找。</p>
<ul>
<li><p>1.声明</p>
<pre><code>  #include&lt;unordered_map&gt;
  unordered_map&lt;int,int&gt; hash;
  //&lt;int,int&gt;里第一个是用来查找的键的数据类型，第二个是值的数据类型，如：
  
  unordered_map&lt;int,int&gt; hash;
  hash[1]=10;hash
</code></pre>
</li>
<li><p>2.访问<br> hash[key];</p>
</li>
<li><p>3.增加（插入）元素</p>
<pre><code>  unordered_map&lt;char,int&gt; hash; 
  
  hash[&quot;a&quot;]=1; //方法1：直接用[] hash[key]=value;
  
  hash.insert(make_pair(&quot;a&quot;,1)); //方法2：make_pair hash.insert(make_pair(key,value));
  
  hash.insert(pair&lt;char,int&gt;(&quot;a&quot;,1)); //方法3：pair  hash.insert(pair&lt;char,int&gt;(key,value)); 
</code></pre>
</li>
<li><p>4.删除元素</p>
<pre><code>  hash.erase(hash.begin()); // erasing by iterator
  
  mymap.erase(&quot;a&quot;);  // erasing by key
  
  mymap.erase(mymap.find(&quot;a&quot;), mymap.end()); // erasing by range
</code></pre>
</li>
<li><p>5.改变元素值</p>
<pre><code>  hash[&quot;a&quot;]=1;
  hash[&quot;a&quot;]=10;// map修改value
</code></pre>
</li>
<li><p>6.查找元素</p>
<pre><code>  //查找元素下标
  hash.find(&quot;a&quot;);
  //查找元素是否存在
  hash.find(&quot;a&quot;)!=hash.end();  //方法一 hash.find()，存在返回迭代器，不存在返回end()

  bool a_in_map=hash.count(&quot;a&quot;)&gt;0?true:false;  //方法二 hash.count() 存在返回1，不存在返回0
</code></pre>
</li>
<li><p>7.遍历</p>
<pre><code>  unordered_map&lt;int,int&gt; map=&#123;
          pair&lt;int,int&gt;(1,2),
          pair&lt;int,int&gt;(3,4)
      &#125;;
  
  //方式一：值传递遍历
  for(pair&lt;int,int&gt; kv:map)&#123;
          cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;
      &#125;
  
  for(auto kv:map)&#123;
          cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;
      &#125;
  
  //遍历set
  for (auto tmp : set)
      &#123;
          cout &lt;&lt; tmp;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="vector-lt-int-gt"><a href="#vector-lt-int-gt" class="headerlink" title="vector&lt;int&gt;"></a>vector&lt;int&gt;</h2><ul>
<li><p>1.为什么要用vector？<br>一般我们使用索引和指针来处理数据，vector的优势是什么呢？数组的越界有可能会引起程序的崩溃，vector可以动态申请空间大小，因此vector相较经典的做法会更加灵活。</p>
</li>
<li><p>2.vector是什么？<br>向量（Vector）是一个封装了<strong>动态大小数组的顺序容器</strong>（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p>
</li>
<li><p>3.定义方法</p>
<pre><code>  (1)vector&lt;int&gt; a(5); //定义了5个整型元素的向量（&lt;&gt;中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的.
  (2）vector&lt;int&gt; a(5,1);//定义了5个整型元素的向量,且给出每个元素的初值为1
  (3）vector&lt;int&gt; a(b); //用b向量来创建a向量，整体复制性赋值
  (4）vector&lt;int&gt; a(b.begin(),b.begin+3); //定义了a值为b中第0个到第2个（共3个）元素
  (5）int b[7]=&#123;1,2,3,4,5,9,8&#125;; vector&lt;int&gt; a(b,b+7); //从数组中获得初值
</code></pre>
</li>
<li><p>4.使用方法<br><strong>添加元素</strong></p>
<pre><code>  nums.push_back(1);//直接从数组末端添加
  nums[i] = 1;//直接赋值给第i个位置
</code></pre>
<p><strong>删除元素</strong></p>
<pre><code>          nums.resize(nums.size-i); //直接将数组长度减小，某种方式上删掉了后面i个
  nums.pop_back();//删掉最后一个元素
</code></pre>
<p><strong>定义二维vector</strong></p>
<ul>
<li><p>1 创建</p>
<pre><code>vector&lt;vector &lt;int&gt; &gt;nums(m ,vector&lt;int&gt;(n)); //m*n的二维vector
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>C++map的三种类型</strong><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240219183924.png"></p>
<h1 id="2-string"><a href="#2-string" class="headerlink" title="2.string"></a>2.string</h1><h2 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h2><ul>
<li><p>1.vector&lt;char&gt;如何与string类型转化<br>使用string类型对vector&lt;char&gt;赋值</p>
<pre><code>  std::string s = &quot;Hello&quot;;
  std::vector&lt;char&gt; str(s.begin(), s.end());
</code></pre>
</li>
<li><p>2.调用string类型数据中特定索引的数据</p>
<pre><code>  std::string s = &quot;Hello&quot;;
  // 使用 operator[] 获取第三个位置的字符
  char c1 = s[2]; // 索引从0开始，所以第三个位置的索引为2
  // 使用at()来获取
  char c2 = s.at(2); // 索引从0开始，所以第三个位置的索引为2
  std::cout &lt;&lt; &quot;第三个位置的字符（使用 at()）：&quot; &lt;&lt; c2 &lt;&lt; std::endl;
</code></pre>
</li>
<li><p>3.删除字符</p>
<pre><code>  string s;
  s.erase(s.begin()+s.size()-1);这样就会删掉指定的元素了
</code></pre>
</li>
<li><p>4.添加字符</p>
<pre><code>  string s=&quot;&quot;;
  s=s+&#39;a&#39;;
</code></pre>
</li>
</ul>
<h2 id="2-简洁的库函数"><a href="#2-简洁的库函数" class="headerlink" title="2.简洁的库函数"></a>2.简洁的库函数</h2><ul>
<li><p>1.字符互换<br><strong>swap:</strong></p>
<pre><code>  swap(s[i],s[j]);
</code></pre>
<p><strong>reverse:</strong></p>
<pre><code>  string a=&quot;123&quot;;
  reserve(a.begin(),a.end());
</code></pre>
<p><strong>to_string</strong>:将int型转换为string类型</p>
<pre><code>  int num = 123;
  double pi = 3.14159;

  std::string numStr = std::to_string(num);
  std::string piStr = std::to_string(pi);
</code></pre>
</li>
<li><p>2.重塑大小<br><strong>resize</strong>:会将后面扩展的元素都设为\0</p>
<pre><code>  string s;
  s.resize(s.size()+1);
</code></pre>
</li>
<li><p>3.KMP算法</p>
</li>
</ul>
<h1 id="3-队列与栈"><a href="#3-队列与栈" class="headerlink" title="3.队列与栈"></a>3.队列与栈</h1><p>队列：先进先出FIFO，栈先入后出</p>
<h2 id="1-队列与栈为什么不是容器？"><a href="#1-队列与栈为什么不是容器？" class="headerlink" title="1.队列与栈为什么不是容器？"></a>1.队列与栈为什么不是容器？</h2><p>容器：容器的通用定义是一种用于存储和操作一组对象的数据结构。它提供了添加、删除、访问、搜索等操作，并且能够根据需要动态调整大小。容器可以是线性的（如向量、链表）、关联的（如映射、集合）或者适配器（如栈、队列）。</p>
<p>2.基础用法<br>顺序栈定义：</p>
<pre><code>    #define MAXSIZE 100
    typedef char Elemtype;  //栈的数据类型
    typedef struct Sqstack
    &#123;
            Elemtype* base;  //栈底指针
            Elemtype* top;  //栈顶指针
            int stacksize;  //栈的最大容量
    &#125;Sqstack;
</code></pre>
<ul>
<li><p>1.长度相关：<br>求顺序栈长度：</p>
<pre><code>  return S.top-S.base
</code></pre>
</li>
</ul>
<p>顺序栈清空和销毁：</p>
<pre><code>    S.base=S.top
</code></pre>
<h1 id="4-二叉树"><a href="#4-二叉树" class="headerlink" title="4.二叉树"></a>4.二叉树</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-二叉树类型"><a href="#1-二叉树类型" class="headerlink" title="1.二叉树类型"></a>1.二叉树类型</h3><ul>
<li>1.满二叉树<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240307200211.png"></li>
<li>2.完全二叉树<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240307200241.png"></li>
<li>3.二叉搜索树<br>若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；<br>若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；<br>它的左、右⼦树也分别为⼆叉排序树<br>下⾯这两棵树都是搜索树：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240307200415.png"></li>
<li>4.平衡二叉搜索树<br>平衡⼆叉搜索树：⼜被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240307200606.png"></li>
</ul>
<h3 id="2-遍历方式"><a href="#2-遍历方式" class="headerlink" title="2.遍历方式"></a>2.遍历方式</h3><p>  <img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240307200728.png"><br>⽤数组来存储⼆叉树如何遍历的呢？<br>如果⽗节点的数组下标是 i，那么它的左孩⼦就是 i * 2 + 1，右孩⼦就是 i * 2 + 2。<br>有两种遍历方式：深度优先遍历和广度优先遍历</p>
<ul>
<li>深度优先遍历<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li>⼴度优先遍历<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p><strong>前序遍历：中左右<br>中序遍历：左中右<br>后序遍历：左右中</strong><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240307201202.png"></p>
<p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。<br><strong>二叉树节点的深度：</strong> 指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）<br><strong>二叉树节点的高度：</strong> 指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</p>
<h3 id="3-删除二叉搜索树节点"><a href="#3-删除二叉搜索树节点" class="headerlink" title="3.删除二叉搜索树节点"></a>3.删除二叉搜索树节点</h3><p><strong>原题如下</strong>：<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/submissions/542208077/" >力扣701<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>解题步骤</strong>：<br>对于一个二叉树来说，如果要写成递归形式就必须要明确以下几个部分：</p>
<ul>
<li>1.确定递归函数参数及返回值</li>
<li>2.确定终止条件</li>
<li>3.确定单层的递归逻辑</li>
</ul>
<p>有以下五种情况：<br><strong>未找到删除的节点</strong></p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
</ul>
<p><strong>找到删除的节点</strong></p>
<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到&#x3D;&#x3D;删除节点的右子树的最左面节点的左孩子上&#x3D;&#x3D;，返回删除节点右孩子为新的根节点。因为右子树的最左面节点的左孩子是整个右子树中的最小的值。</li>
</ul>
<h3 id="4-将有序数组转换为平衡二叉搜索树"><a href="#4-将有序数组转换为平衡二叉搜索树" class="headerlink" title="4.将有序数组转换为平衡二叉搜索树"></a>4.将有序数组转换为平衡二叉搜索树</h3><p>原题如下：<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/" >力扣108<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="5-回溯"><a href="#5-回溯" class="headerlink" title="5.回溯"></a>5.回溯</h1><p>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<h2 id="1-回溯法可以解决的问题"><a href="#1-回溯法可以解决的问题" class="headerlink" title="1.回溯法可以解决的问题"></a>1.回溯法可以解决的问题</h2><p><strong>组合问题：</strong> N个数里面按一定规则找出k个数的集合<br><strong>切割问题：</strong> 一个字符串按一定规则有几种切割方式<br><strong>子集问题：</strong> 一个N个数的集合里有多少符合条件的子集<br><strong>排列问题：</strong> N个数按一定规则全排列，有几种排列方式<br><strong>棋盘问题：</strong> N皇后，解数独等等<br>（组合无序，排列有序）</p>
<h2 id="2-如何理解"><a href="#2-如何理解" class="headerlink" title="2.如何理解"></a>2.如何理解</h2><p>回溯法解决的问题都可以抽象为<strong>树形结构</strong><br>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。</p>
<h2 id="3-回溯问题的流程"><a href="#3-回溯问题的流程" class="headerlink" title="3.回溯问题的流程"></a>3.回溯问题的流程</h2><p>1.回溯函数模板返回值以及参数<br>回溯算法中函数返回值一般为void。<br>2.回溯函数终止条件<br>3.回溯搜索的遍历过程</p>
<h2 id="4-去重问题"><a href="#4-去重问题" class="headerlink" title="4.去重问题"></a>4.去重问题</h2><p>原题如下：<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/description/" >力扣40<i class="fas fa-external-link-alt"></i></a><br>1.先对输入的序列进行排序，这一步主要是将所有相同的元素都连在一起<br>2.声明一个used数组用于记录是否重复调用，如果candidate[i]&#x3D;&#x3D;candidate[i-1]&amp;&amp;used[i-1]&#x3D;0 就说明这已经不是第一次调用了，前面已经有人调用过这一情况了，所以不要重复选取直接下一个。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240627204119.png"></p>
<h1 id="6-贪心算法"><a href="#6-贪心算法" class="headerlink" title="6.贪心算法"></a>6.贪心算法</h1><h1 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7.动态规划"></a>7.动态规划</h1><h2 id="1-解题步骤"><a href="#1-解题步骤" class="headerlink" title="1.解题步骤"></a>1.解题步骤</h2><p>1.确定dp数组（dp table）以及下标的含义<br>2.确定递推公式<br>3.dp数组如何初始化<br>4.确定遍历顺序<br>5.举例推导dp数组</p>
<h2 id="2-排列与组合问题"><a href="#2-排列与组合问题" class="headerlink" title="2.排列与组合问题"></a>2.排列与组合问题</h2><p>排列问题：在背包中每个物体只能选择一次，所以遍历的顺序无所谓，先背包空间还是先物体种类遍历都无所谓<br>组合问题：背包中的物体可以选无数次，所以外侧必须为背包空间，而内侧为物体种类，保证从小到大每个组合种类都已经被遍历到，然后向上推进。</p>
<pre><code>    class Solution &#123;
            public:
            int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;
                    vector&lt;int&gt;dp(target+1,0);
                    dp[0]=1;
                    for(int i = 0;i&lt;=target;i++)&#123;
                    for(int j =0;j&lt;nums.size();j++)&#123;
                            if (i - nums[j] &gt;= 0 &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]])&#123;
                            dp[i]+=dp[i-nums[j]];
                            &#125;
                    &#125;
                    &#125;
                    return dp[target];
            &#125;
    &#125;;
</code></pre>
<h1 id="8-图论"><a href="#8-图论" class="headerlink" title="8.图论"></a>8.图论</h1><h2 id="1-两个图的存储方式"><a href="#1-两个图的存储方式" class="headerlink" title="1.两个图的存储方式"></a>1.两个图的存储方式</h2><ul>
<li>邻接表：数组+链表，从边的数量来表示图，有多少边申请对应大小的链表</li>
<li>邻接矩阵：一个二维数组，有多少节点就申请多大的二维矩阵，如果有n个节点，就申请n*n大小的二维矩阵</li>
</ul>
<h2 id="2-图的遍历方式"><a href="#2-图的遍历方式" class="headerlink" title="2.图的遍历方式"></a>2.图的遍历方式</h2><ul>
<li>1.<strong>深度优先遍历</strong> dfs：<strong>dfs</strong>是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240713161012.png"><br>表达的图：<ul>
<li><p>节点1 指向 节点3 和 节点5</p>
</li>
<li><p>节点2 指向 节点4、节点3、节点5</p>
</li>
<li><p>节点3 指向 节点4</p>
</li>
<li><p>节点4指向节点1</p>
<pre><code>// 节点编号从1到n，所以申请 n+1 这么大的数组
vector&lt;list&lt;int&gt;&gt; graph(n + 1); // 邻接表，list为C++里的链表
while (m--) &#123;
        cin &gt;&gt; s &gt;&gt; t;
        // 使用邻接表 ，表示 s -&gt; t 是相连的
        graph[s].push_back(t);
&#125;
</code></pre>
</li>
</ul>
</li>
<li>2.<strong>广度优先遍历</strong> bfs：bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。<br>有点类似二叉树的深度遍历和层序遍历</li>
</ul>
<h2 id="3-深度搜索三部曲"><a href="#3-深度搜索三部曲" class="headerlink" title="3.深度搜索三部曲"></a>3.深度搜索三部曲</h2><ul>
<li>1.确认递归函数，参数</li>
<li>2.确认终止条件</li>
<li>3.处理目前搜索节点出发的路径</li>
</ul>
<h2 id="4-广度搜索更适用的题目"><a href="#4-广度搜索更适用的题目" class="headerlink" title="4.广度搜索更适用的题目"></a>4.广度搜索更适用的题目</h2><ul>
<li>最短路径：广搜一圈一圈，只要最先到的就肯定是最短路径。</li>
</ul>
<p>上面都是一些具体的解题思路：接下来来点八股数据结构会考的问题</p>
<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="1-哈夫曼树"><a href="#1-哈夫曼树" class="headerlink" title="1.哈夫曼树"></a>1.哈夫曼树</h2><p>哈夫曼树构造取最小值的两个节点，然后后面将这两个节点求和合并为一个节点，然后重复这个步骤</p>
<h3 id="1-哈夫曼带权路径长度计算"><a href="#1-哈夫曼带权路径长度计算" class="headerlink" title="1.哈夫曼带权路径长度计算"></a>1.哈夫曼带权路径长度计算</h3><p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240810214428.png"><br>例如上面这个树，A有两个路径，E也有两个路径（从根节点来说），所以可以写出以下式子：5*2+10*2+15*1</p>
<h3 id="2-哈夫曼编码"><a href="#2-哈夫曼编码" class="headerlink" title="2.哈夫曼编码"></a>2.哈夫曼编码</h3><p>哈夫曼编码是一个以频率来看的编码形式，先构造成哈夫曼树，接着从上到下写下来。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240810215018.png"></p>
<p>将左子树设为0，右子树设为1，，从跟根节点一路写下来，就是我们得到的哈夫曼编码。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240810215037.png"></p>
<h2 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h2><p>重新归拢一下《大话数据结构的内容》</p>
<h3 id="1-有序表查找"><a href="#1-有序表查找" class="headerlink" title="1.有序表查找"></a>1.有序表查找</h3><p>有序表都有一个缺点就是要求有序，有序的<strong>插入和删除效率就明显很差</strong></p>
<ul>
<li><p>1.<strong>折半查找</strong>：<br>折半查找，找到了就停手不继续找了，如果最后没有找到的话就无了。<br><strong>时间复杂度</strong>：logn（因为这个就是一个二叉树）下面的两种查找方式计算复杂度也都是&#x3D;&#x3D;logn&#x3D;&#x3D;</p>
<pre><code>  int main()&#123;
  vector&lt;int&gt; vec = &#123;0,1,2,3,4,5,6,7,8,9,10&#125;;
  int target = 8;
  int left = 1;
  int right =11;
  while(left&lt;=right)&#123;
          int mid = (left+right)/2;
          if(vec[mid]&gt;target)right = mid-1;
          else if (vec[mid]&lt;target)left = mid+1;
          else&#123;
          cout&lt;&lt;mid;
          break;
          &#125;
  &#125;
  cout&lt;&lt;&quot;not find&quot;&lt;&lt;endl;
  &#125;
</code></pre>
</li>
<li><p>2.<strong>插值查找</strong>：实际上只是折半查找的翻版，更改mid的取值方式</p>
</li>
<li><p>3.<strong>斐波那契查找</strong>：根据数量在斐波那契数列中的位置来判定，F&#x3D;{0,1,1,2,3,5,8,13….}这样子，如果我输入一个数量为10的数列，则F[6]&lt; n &lt; F[7]，计算从F[7]&#x3D;13为基础，要把10后面的值给补全。</p>
</li>
</ul>
<h3 id="2-二叉排序树"><a href="#2-二叉排序树" class="headerlink" title="2.二叉排序树"></a>2.二叉排序树</h3><p>由于有序才好查找，但是线性表的删除和插入的效率太烂了，所以换成二叉树的形式。<br>二叉排序树：又称二叉查找树，有以下特性：</p>
<ul>
<li>1.若他的左子树不空，则左子树上所有节点都要小于根节点的值</li>
<li>2.右子树不空，则右子树所有节点都要大于根节点的值</li>
<li>3.左右子树也都是二叉排序树</li>
</ul>
<h4 id="1-构造二叉排序树"><a href="#1-构造二叉排序树" class="headerlink" title="1.构造二叉排序树"></a>1.构造二叉排序树</h4><h4 id="2-二叉排序树插入节点"><a href="#2-二叉排序树插入节点" class="headerlink" title="2.二叉排序树插入节点"></a>2.二叉排序树插入节点</h4><h4 id="3-二叉排序树删除节点"><a href="#3-二叉排序树删除节点" class="headerlink" title="3.二叉排序树删除节点"></a>3.二叉排序树删除节点</h4><ul>
<li>1.第一种情况：叶子节点，叶子节点没有子树，所以删掉就删掉了</li>
<li>2.第二种情况：只有一个子树，该子树直接接到之前这个节点接的节点上就好了</li>
<li>3.第三种情况：既有左子树又有右子树，这个就比较麻烦了<ul>
<li>找出左子树中最大或者右子树中最小的值val</li>
<li>将当前节点的值替换为val</li>
<li>在左子树或者右子树中找到val删除<br>&#x3D;&#x3D;(这块还是得重新再来几遍)&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h3 id="3-平衡二叉树（AVL树）"><a href="#3-平衡二叉树（AVL树）" class="headerlink" title="3.平衡二叉树（AVL树）"></a>3.平衡二叉树（AVL树）</h3><p>平衡二叉树 左右子树高度之差的绝对值不超过1 ，左子树高度-右子树高度的值被称为平衡因子BF</p>
<h3 id="4-哈希表"><a href="#4-哈希表" class="headerlink" title="4.哈希表"></a>4.哈希表</h3><p>散列技术：记录的存储位置和他的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)，散列函数也称为哈希函数。采用散列技术将记录存储在一块连续的存储空间中，这块存储空间称为<strong>哈希表</strong>。</p>
<h4 id="1-散列函数的构造方法"><a href="#1-散列函数的构造方法" class="headerlink" title="1.散列函数的构造方法"></a>1.散列函数的构造方法</h4><p>构造方法五花八门，本质就是通过将数字直接映射到一个存储地址上。</p>
<h4 id="2-散列冲突的解决办法"><a href="#2-散列冲突的解决办法" class="headerlink" title="2.散列冲突的解决办法"></a>2.散列冲突的解决办法</h4><ul>
<li>1.开放定址法<ul>
<li>1.线性探测法：如果位置已经被占上了，那就直接依次向后推，直到后面出现了空位占位。f&#x3D;(k+di)MODm(di &#x3D; 1,2,3,4,5..m-1)</li>
<li>2.二次探测法<br>类似上面的的方法，但是式子改为平方：f&#x3D;(k+di)MODm(di &#x3D; 1^2,-1^2,2^2,-2^2,…)</li>
<li>3.随机探测法<br>di直接全是伪随机数</li>
</ul>
</li>
<li>2.再散列函数法<br>实现准备多个散列函数，如果发生了哈希冲突就换一个继续算</li>
<li>3.链地址法<br>不换位置了，在地址后面加链表，只要重名了就在链表后面加内容</li>
<li>4.公共溢出区法<br>冲突的丢到溢出表里去，如果基本表查找到了最好，如果没查找到，那就去溢出表顺序查找。</li>
</ul>
<h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3.排序"></a>3.排序</h2><p>这里我把所有会涉及到的排序问题都重新整理一遍</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p>从前向后两两比较排序，如果逆向就交换，依次类推。<br><strong>时间复杂度</strong>：O(n^2^)</p>
<pre><code>    class Solution&#123;
    public:
    void sort(vector&lt;int&gt;&amp; num)&#123;
            int len = num.size();
            for(int i=0;i&lt;len;i++)&#123;
            for(int j=len-1;j&gt;i;j--)&#123;
                    if(num[j]&lt;num[j-1])swap(num[j],num[j-1]);
            &#125;
            &#125;
    &#125;
    &#125;;
</code></pre>
<h3 id="2-简单选择排序"><a href="#2-简单选择排序" class="headerlink" title="2.简单选择排序"></a>2.简单选择排序</h3><p>和冒泡函数区别不大，只是将直接swap转为了判断最小值，接着记录最小值的位置</p>
<h3 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3.直接插入排序"></a>3.直接插入排序</h3><p>基本操作是将一个记录插入到排好序的有序表中<br><strong>步骤</strong>：</p>
<ul>
<li>1.先开辟一个用于存储的空间</li>
<li>2.将需要调整的数存储下来</li>
<li>3.由于该值之前的都已经被调序为有序表，所以只需要插入该值就好，以此类推成功插入。</li>
</ul>
<p>时间复杂度:O(n^2^)</p>
<pre><code>    class Solution&#123;
    public:
    void sort(vector&lt;int&gt;&amp; num)&#123;
            int length = num.size();
            //在vector最前面的位置插入一个空位
            num.insert(num.begin(),0);
            int j = 0;
            for(int i = 2;i&lt;=length;i++)&#123;
            if(num[i]&lt;num[i-1])&#123;
                    num[0] = num[i];
                    for(j = i-1;num[j]&gt;num[0];j--)&#123;
                    num[j+1] = num[j];
                    &#125;
                    num[j+1] = num[0]; 
            &#125;
            &#125;
            num.erase(num.begin());
    &#125;
    &#125;;
</code></pre>
<h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h3><p>就是先把序列变得相对比较对，后面再通过最后之前的inc&#x3D;1从头到后排一遍最终排序。<br>时间复杂度：log(n^2&#x2F;3^)</p>
<pre><code>    class Solution&#123;
    public:
    void sort(vector&lt;int&gt;&amp; num)&#123;
            int inc = num.size();
            while(inc&gt;1)&#123;
            inc = inc/3+1;
            for(int i=0;i&lt;num.size()-inc;i++)&#123;
                    if(num[i]&gt;num[i+inc])swap(num[i],num[i+inc]);
            &#125;
            int a= 1;
            &#125;
    &#125;
</code></pre>
<p>};</p>
<h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h3><p>分类：大顶堆和小顶堆，大顶堆堆顶元素就是最大值<br>步骤：</p>
<ul>
<li><p>1.构造一个大顶堆，保证非叶子节点都是大顶堆分布</p>
</li>
<li><p>2.数组第一个值与最后一个调换，同时重新堆排序（这次算上所有可用的元素）。</p>
<pre><code>  class Solution&#123;
  public:
  void heap(vector&lt;int&gt;&amp; num,int n,int i)&#123;
          int left = 2*i+1;
          int right = 2*i+2;
          int large = i;
          if(left&lt;n &amp;&amp;num[left]&gt;num[large])&#123;
          large = left;
          &#125;
          if(right&lt;n &amp;&amp;num[right]&gt;num[large])&#123;
          large = right;
          &#125;
          if(large != i)&#123;
          swap(num[i],num[large]);
          heap(num,n,large);
          &#125;
  &#125;
  void sort(vector&lt;int&gt;&amp; num)&#123;
          int length = num.size();
          for(int i = length/2-1;i&gt;=0;i--)&#123;
          heap(num,length,i);
          &#125;
          for(int i = num.size()-1;i&gt;=0;i--)&#123;
          swap(num[0],num[i]);
          heap(num,i,0);
          &#125;
  &#125;
  &#125;;
</code></pre>
</li>
</ul>
<h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h3><p>主要思想是将整个数组分成1的小数组，然后将小数组排序后1+1&#x3D;2，2+2&#x3D;4….慢慢合成一整个已经排序好的大数组</p>
<pre><code>    class Solution&#123;
    public:
    void guibing(vector&lt;int&gt;&amp;vec,int left,int mid,int right)&#123;
            vector&lt;int&gt;ll(mid-left+1);
            vector&lt;int&gt;rr(right-mid);
            for(int i = 0;i&lt;ll.size();i++)&#123;
                    ll[i] = vec[left+i];
            &#125;
            for(int i = 0;i&lt;rr.size();i++)&#123;
                    rr[i] = vec[mid+i+1];
            &#125;
            int i = 0,j=0,k=left;
            while(i&lt;ll.size()&amp;&amp;j&lt;rr.size())&#123;
            if(ll[i]&lt;rr[j])&#123;
                    vec[k++]=ll[i++];
            &#125;
            else&#123;
                    vec[k++]=rr[j++];
            &#125;
            &#125;   
            while(i&lt;ll.size())&#123;
                    vec[k++]=ll[i++];
            &#125;
            while(j&lt;rr.size())&#123;
                    vec[k++]=rr[j++];
            &#125;
    &#125;
    void sort(vector&lt;int&gt;&amp;vec,int left,int right)&#123;
            if(left&lt;right)&#123;
                    int mid = (left+right)/2;
                    sort(vec,left,mid);
                    sort(vec,mid+1,right);
                    guibing(vec,left,mid,right);
            &#125;
    &#125;
    &#125;;
</code></pre>
<h3 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h3><p>快速排序先将最左的元素设为key，然后将左右指针比较大小分别交换位置，接着将key赋值给二者相同的地方，这样就被分为了全都比key小和全都比key大两个部分，然后递归调用这个函数，对得到的这两个vec重新排序，以此类推。</p>
<pre><code>    class Solution&#123;
    public:
    void sort(vector&lt;int&gt;&amp;vec,int left,int right)&#123;
            if(left&gt;=right)return ;
            int begin = left;
            int end = right;
            int key = vec[left];
            while(begin&lt;end)&#123;
                    while(end&gt;begin&amp;&amp;vec[end]&gt;=key)&#123;
                            end--;
                    &#125;
                    vec[begin] =vec[end];
                    while(end&gt;begin&amp;&amp;vec[begin]&lt;=key)&#123;
                            begin++;
                    &#125;
                    vec[end] = vec[begin];
            &#125;
            vec[begin] = key;
            sort(vec,left,begin-1);
            sort(vec,begin+1,right);
    &#125;
    &#125;;
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-为什么使用迭代器使用的-gt-first，但是对于哈希表unordered-map类型的数据就用的是-first"><a href="#1-为什么使用迭代器使用的-gt-first，但是对于哈希表unordered-map类型的数据就用的是-first" class="headerlink" title="1.为什么使用迭代器使用的-&gt;first，但是对于哈希表unordered_map类型的数据就用的是.first"></a>1.为什么使用迭代器使用的-&gt;first，但是对于哈希表unordered_map类型的数据就用的是.first</h2><p>答：引用就使用.first，指针就使用-&gt;first。<br><strong>引用与指针：</strong><br><strong>使用方式</strong>：<br>引用在使用时就像是被引用的变量本身一样，不需要使用*符号进行解引用。比如，a &#x3D; 10; 就相当于 b &#x3D; 10; 因为a和b在内存中存储的是同一个地址。<br>指针：指针在使用时需要使用*符号进行解引用，才能访问存储在该地址上的变量。比如，*p &#x3D; 10; 就相当于 a &#x3D; 10; 因为p存储的是a变量的内存地址。<br><strong>那么引用有什么卵用呢？</strong><br>引用在函数调用时可以避免复制大量的内存，因为它们是其所引用的变量的别名。在函数中对引用的修改会直接反映在原始变量上。</p>
<h2 id="2-怎么对哈希表的第二个数值进行升序排列"><a href="#2-怎么对哈希表的第二个数值进行升序排列" class="headerlink" title="2.怎么对哈希表的第二个数值进行升序排列"></a>2.怎么对哈希表的第二个数值进行升序排列</h2><p>  正常情况下是无法直接使用sort对哈希表的第二个数值进行升序排序的，想要排序需要处理以下几步<br>  1.将哈希表转化为pair形式</p>
<pre><code>    unordermap&lt;int,int&gt; a;
    vector&lt;pair&lt;int,int&gt;&gt;vec(a.begin(),map.end());
</code></pre>
<p>2.自定义以第二个键值作为sort的标准</p>
<pre><code>    bool static cmp (const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123;
    return a.second &gt; b.second; // 按照频率从大到小排序
    &#125;
</code></pre>
<p>接着带入到sort里</p>
<pre><code>    sort(vec.begin(),vec.end(),cmp);
</code></pre>
<h2 id="3-红黑树与平衡二叉树的差别"><a href="#3-红黑树与平衡二叉树的差别" class="headerlink" title="3.红黑树与平衡二叉树的差别"></a>3.红黑树与平衡二叉树的差别</h2><h3 id="1-平衡二叉树"><a href="#1-平衡二叉树" class="headerlink" title="1.平衡二叉树"></a>1.平衡二叉树</h3><ul>
<li>规则1：每个节点最多只有两个子节点（二叉）</li>
<li>规则2：每个节点的值比它的左子树所有的节点大，比它的右子树所有节点小（有序）</li>
<li><strong>规则3</strong>：每个节点左子树的高度与右子树高度之差的绝对值不超过1</li>
</ul>
<h4 id="1-如何构造平衡二叉树"><a href="#1-如何构造平衡二叉树" class="headerlink" title="1.如何构造平衡二叉树"></a>1.如何构造平衡二叉树</h4><p>左左：右旋解决<br>左右：先左旋再右旋<br>右右：左旋解决<br>右左：先右旋再左旋</p>
<p><em><strong>左左：</strong></em><br>插入前二叉树是平衡&#x3D;的，但是插入后不平衡了，同时不平衡是由于3号的<strong>左孩子</strong>节点新增了一个<strong>左孩子</strong>，所以被叫做左左，应对的方法是<strong>右旋</strong><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818104601.png"><br>右旋后：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818104807.png"></p>
<p><em><strong>左右：</strong></em><br>如果3号是新插入的节点，在未插入之前，二叉树是平衡的，插入之后4号节点左右不平衡了，这种不平衡是34号的<strong>左孩子</strong>节点，新增了一个<strong>右孩子</strong>,我们的方法是<strong>先左旋再右旋</strong>。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818104921.png"><br>结果：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818104952.png"></p>
<h3 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2.红黑树"></a>2.红黑树</h3><p>红黑树的规则：<br>规则1: 每个节点不是黑色就是红色<br>规则2： 根节点为黑色<br>规则3：红色节点的父节点和子节点不能为红色<br>规则4：所有的叶子节点都是黑色（空节点视为叶子节点NIL）<br>规则5：每个节点到叶子节点的每个路径黑色节点的个数都相等。</p>
<h4 id="1-平衡二叉树和红黑树的区别"><a href="#1-平衡二叉树和红黑树的区别" class="headerlink" title="1.平衡二叉树和红黑树的区别"></a>1.平衡二叉树和红黑树的区别</h4><ul>
<li>平衡二叉树的左右子树的高度差绝对值不超过1，但是<strong>红黑树在某些时刻可能会超过1，只要符合红黑树的五个条件即可</strong>。</li>
<li>二叉树只要不平衡就会进行旋转，而红黑树不符合规则时，有些情况只用改变颜色不用旋转，就能达到平衡。</li>
</ul>
<p>红黑树保持平衡的操作：变色+旋转</p>
<h4 id="2-红黑树保持平衡操作："><a href="#2-红黑树保持平衡操作：" class="headerlink" title="2.红黑树保持平衡操作："></a>2.红黑树保持平衡操作：</h4><ul>
<li><p>变色：<br>此时这个为树的一部分，这是违反了子节点与父节点不能为红色<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818144917.png"><br>使用变色来解决<br>第一步：将父节点3和叔节点8变黑<br>第二步，将奶奶节点5变红。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818145035.png"></p>
</li>
<li><p>旋转：<br>如果变色的方法不可用，那么我们需要使用旋转的方法。红黑树的旋转和平衡二叉树的旋转一样，只不过多了变色的步骤。<br>如果红色节点的<strong>父节点为红色，叔节点为黑色</strong>，那么我们就需要使用旋转的方法。<br>（1）左左<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818145145.png"><br>右旋之后我们将原来的父节点变黑，将原来的奶奶节点变红<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818145205.png"><br>（2）左右<br>右旋再左旋：如图是红黑树的一部分，8号节点的父节点为红色，叔节点为黑色。8号节点为右节点，8号节点的父节点为左节点，所以符合左右的情况。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818145249.png"><br>使用左转右转再变色<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240818145322.png"></p>
</li>
</ul>
<h4 id="3-构造红黑树"><a href="#3-构造红黑树" class="headerlink" title="3.构造红黑树"></a>3.构造红黑树</h4><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44780082/article/details/112239269?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172396309616800225586124%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172396309616800225586124&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112239269-null-null.142%5Ev100%5Epc_search_result_base5&utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1018.2226.3001.4187" >红黑树与平衡二叉树<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="4-面试回答版"><a href="#4-面试回答版" class="headerlink" title="4.面试回答版"></a>4.面试回答版</h4><p><strong>怎么实现插入操作</strong>：</p>
<ul>
<li>将新插入的节点设为红色。</li>
<li>若违反了红黑树性质4，则进行一系列旋转和变换来修正。</li>
<li>最后将根节点设为黑色。</li>
</ul>
<p><strong>怎么实现删除操作</strong>：</p>
<ul>
<li>若被删除节点有两个非空子节点，则找到其后继节点（右子树的最小值或左子树的最大值），用后继节点替代原节点，再删除后继节点。</li>
<li>若被删除节点只有一个子节点或没有子节点，则直接删除。</li>
<li>删除后，若违反了红黑树性质4，则进行一系列旋转和变换来修正。</li>
</ul>
<h4 id="5-所以为什么map使用的是红黑树而不是平衡二叉树呢？"><a href="#5-所以为什么map使用的是红黑树而不是平衡二叉树呢？" class="headerlink" title="5.所以为什么map使用的是红黑树而不是平衡二叉树呢？"></a>5.所以为什么map使用的是红黑树而不是平衡二叉树呢？</h4><p><strong>1.性能</strong>：</p>
<ul>
<li>红黑树：红黑树是一种 弱平衡 二叉搜索树。在红黑树中，通过允许树的某些部分稍微不平衡，红黑树在<strong>插入和删除节点时，旋转次数较少</strong>。</li>
<li>AVL树：AVL 树是一种 严格平衡 的二叉搜索树，在任何时候 AVL 树的每个节点的两个子树高度差不超过 1。尽管 AVL 树的<strong>查找效率比红黑树稍好</strong>，因为它更严格地保持平衡，但在插入和删除节点时，AVL 树往往需要<strong>更多的旋转操作</strong>以保持平衡，从而使这些操作的开销更大。<br><strong>2.查询功能</strong><br>AVL树要比红黑树的效率更高，但对于混合的插入、删除和查询操作，性能提升可能不足以抵消插入和删除操作的额外开销。</li>
</ul>
<p>因此红黑树的设计目标是在插入、删除和查询操作之间取得较好的平衡。虽然查询性能略逊于 AVL 树，但它在插入和删除操作的性能上更优，从而使其在综合应用场景中具有更好的表现。所以map选择使用红黑树而不是平衡二叉树</p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2>
            </div>

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2024/01/01/%E3%80%8A%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%8B/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">《网络是怎样连接的》</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2024/01/01/%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">驱动实现</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2024
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">caijiQAQ</a>
            
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>










<div class="post-scripts">
    
        
<script src="/js/post-helper.js"></script>

        
        
    
</div>



</body>
</html>
