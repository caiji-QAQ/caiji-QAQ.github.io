<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="caijiQAQ">
    
    <title>
        
            C++面试 |
        
        学习笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"caiji-qaq.github.io","root":"/","language":"en"}
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"header_transparent":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":false,"preload":false},"code_copy":{},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":false,"min2read":false},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               学习笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">C++面试</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">caijiQAQ</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2024-01-01 09:28:41</span>
        <span class="mobile">2024-01-01 09:28</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2024-07-01 22:41:56</span>
    </span>
    
    
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h3 id="1-const关键字"><a href="#1-const关键字" class="headerlink" title="1.const关键字"></a>1.const关键字</h3><ul>
<li>1.常量指针：const修饰的时这个int指针指代的对象的不可改变性<br><strong>const</strong> int* a &#x3D;&amp;temp;</li>
<li>2.指针常量：const修饰的是p这个指针地址，也就是地址不可修改<br>int * const p &#x3D;&amp;temp;<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PicgoImage@main/img/202404161630875.png"><br>3.<strong>常量指针与指针常量的区别：</strong><br>常量指针一般const关键字在*之前，但是在指针常量中const在*之后。<br>常量指针是指针本身是常量，内容可变，但是本身地址不能变<br>指针常量是指针所指向的内容是常量，指针本身可变</li>
</ul>
<h3 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2.static关键字"></a>2.static关键字</h3><p>1.静态变量</p>
<ul>
<li>static修饰的变量是静态变量</li>
<li>作用：声明的静态变量会在程序的整个生命周期中存在，不会因为离开作用域而销毁</li>
</ul>
<p>2.静态函数</p>
<ul>
<li>static修饰的函数时静态函数</li>
<li>作用：静态函数属于类而不是类的实例，可以通过类名直接调用，而无需创建对象。</li>
<li>静态函数不能直接访问非静态成员变量或非静态成员函数。</li>
<li>作用域限制：静态函数通常只在声明它的文件中可见，其他文件不能访问。这有助于减少函数的全局可见性，从而减少命名冲突。</li>
</ul>
<p>3.静态成员变量</p>
<ul>
<li>声明在类内，定义要<strong>在类外面定义</strong></li>
<li>所有类的对象共享一个静态成员变量的副本</li>
</ul>
<p>4.静态成员函数</p>
<ul>
<li>静态成员函数不能直接访问⾮静态成员变量或⾮静态成员函数。</li>
</ul>
<h3 id="3-define与typedef的区别"><a href="#3-define与typedef的区别" class="headerlink" title="3.define与typedef的区别"></a>3.define与typedef的区别</h3><ul>
<li>1.define是预处理指令，简单的机械替换</li>
<li>2.typedef是关键字，有类型检查功能；typedef 提供了类型安全，因为它只能用于为现有类型定义别名，而不能进行简单的文本替换。typedef会在变异其中解释和检查，而define只是简单的文本替换</li>
</ul>
<h3 id="4-inline的作用"><a href="#4-inline的作用" class="headerlink" title="4.inline的作用"></a>4.inline的作用</h3><p>正常编译一个函数的时候，编译器生成一个机器指令来调用函数，运行到的位置会将当前的程序计数器（指向下一条指令的地址）保存到栈上，并跳转到函数的地址上。但是inline声明的函数可以直接将函数直接插入到调用点，也就不再需要参数传递和栈等操作了。因此inline的函数最好是选择一些短小的函数，否则频繁调用会让代码膨胀。</p>
<h3 id="5-new与malloc的区别"><a href="#5-new与malloc的区别" class="headerlink" title="5.new与malloc的区别"></a>5.new与malloc的区别</h3><p>new</p>
<pre><code>  int* ptr = new int(10);  // 分配内存并初始化为 10
  int* array = new int[5]; // 分配一个包含 5 个整数的数组
</code></pre>
<p>  malloc</p>
<pre><code>  int* ptr = (int*) malloc(sizeof(int));
  int* array = (int*) malloc(5 * sizeof(int));
</code></pre>
<p>1.类型安全性：</p>
<ul>
<li>new 是C++的运算符，可以为对象分配内存并调⽤相应的构造函数。</li>
<li>malloc 是C语⾔库函数，只分配指定⼤⼩的内存块，不会调⽤构造函数。</li>
</ul>
<p>2.返回类型：</p>
<ul>
<li>new 返回的是具体类型的指针，⽽且不需要进⾏类型转换。</li>
<li>malloc 返回的是 void* ，需要进⾏<strong>类型转换</strong>，因为它不知道所分配内存的⽤途。</li>
</ul>
<p>3.内存分配失败时的⾏为：</p>
<ul>
<li>new 在内存分配失败时会抛出 std::bad_alloc 异常。</li>
<li>malloc 在内存分配失败时返回 NULL 。</li>
</ul>
<p>4.内存块⼤⼩：</p>
<ul>
<li>new 可以⽤于动态分配数组，并知道数组⼤⼩。</li>
<li>malloc 只是分配指定⼤⼩的内存块，不了解所分配内存块的具体⽤途。</li>
</ul>
<p>5.释放内存的⽅式：</p>
<ul>
<li>delete 会调⽤对象的析构函数，然后释放内存。</li>
<li>free 只是简单地释放内存块，不会调⽤对象的析构函数。</li>
</ul>
<h3 id="6-volatile关键字是什么"><a href="#6-volatile关键字是什么" class="headerlink" title="6.volatile关键字是什么"></a>6.volatile关键字是什么</h3><p>关键字 volatile 在 C 和 C++ 中用来告诉编译器，某个变量的值可能会在程序外部被改变，因此编译器在使用这个变量的时候不应该对其访问做任何优化。例如：<img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240416224523.png"></p>
<h3 id="7-原子操作"><a href="#7-原子操作" class="headerlink" title="7.原子操作"></a>7.原子操作</h3><p>原子操作在处理多线程或多进程环境中的数据共享和竞争条件时非常重要。如果操作是原子的，你就可以确保在任何时刻<strong>只有一个线程</strong>能修改该数据，从而避免了竞争条件和其他一些常见的多线程问题。<br>在 C++11 及之后的版本中，标准库提供了 &lt;atomic&gt; 头文件，其中包含了一系列用于执行原子操作的模板和函数。这允许你声明原子类型的变量，以及安全地在多线程环境中对这些变量进行操作。std::atomic 类型封装了一些基础类型（如 int、long 等），并提供了一系列方法来进行安全的原子操作。也就是原子操作可以保证在线程操作的时候不会出现数据竞争。</p>
<h3 id="8-struct-和class的区别"><a href="#8-struct-和class的区别" class="headerlink" title="8.struct 和class的区别"></a>8.struct 和class的区别</h3><p>通常， struct ⽤于表示⼀组<strong>相关的数据</strong>，⽽ class ⽤于表示<strong>⼀个封装了数据和操作的对象</strong>,在实际使⽤中，可以根据具体的需求选择使⽤ struct 或 class 。如果只是⽤来组织⼀些数据，⽽不涉及复杂的封装和继承关系， struct 可能更直观；如果需要进⾏封装、继承等&#x3D;&#x3D;⾯向对象编程&#x3D;&#x3D;的特性，可以选择使⽤ class 。</p>
<ul>
<li>struct 继承时默认使⽤<strong>公有</strong>继承。class 继承时默认使⽤<strong>私有</strong>继承。</li>
<li>如果struct和class都没有声明构造函数，那么编译器就会生成默认的无参数构造函数</li>
</ul>
<h3 id="9-C-内存分区"><a href="#9-C-内存分区" class="headerlink" title="9.C++内存分区"></a>9.C++内存分区</h3><p>从低地址到高地址：<br>1.代码区：存放程序代码<br>2.常量区：常量区也被称为只读区。存储常量数据，如字符串常量<br>3.全局静态区:用于存储全局变量和静态变量：寿命在整个程序<br>4.堆：用于存储动态分配内存的区域，由程序员动态分配和释放。包括使用new&#x2F;<br>malloc+delete&#x2F;free<br>5.栈：栈⽤于存储函数的局部变量、函数参数和函数调⽤信息的区域。函数的调⽤和返回通过栈来管理</p>
<h3 id="10-栈与堆的区别"><a href="#10-栈与堆的区别" class="headerlink" title="10.栈与堆的区别"></a>10.栈与堆的区别</h3><ul>
<li>1.栈：栈上的变量⽣命周期与其所在<strong>函数的执⾏周期相同</strong></li>
<li>2.堆：堆上的变量⽣命周期<strong>由程序员显式控制</strong>，可以（使⽤ new或 malloc ）和释放（使⽤ delete 或 free ）。</li>
<li>栈上的内存分配和释放是<strong>⾃动的，速度较快</strong>。⽽堆上的内存分配和释放需要⼿动操作，<strong>速度相对较慢</strong></li>
</ul>
<h3 id="11-内存泄漏"><a href="#11-内存泄漏" class="headerlink" title="11.内存泄漏"></a>11.内存泄漏</h3><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使⽤的内存的情况。内存泄漏并⾮指内存在物理上的消失，⽽是应⽤程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因⽽造成了内存的浪费。<br>内存泄漏的分类：</p>
<ul>
<li>1.堆内存泄漏：<br>使用malloc、new等方法从堆中分配一块地址，最终导致没有释放，这块地址就会产生堆内存泄漏</li>
<li>2.系统资源泄露<br>主要指程序使⽤系统分配的资源⽐如 Bitmap,handle ,SOCKET 等没有使⽤相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运⾏不稳定。 </li>
<li>3.没有将基类的析构函数定义为虚函数<br>当基类指针指向⼦类对象时，如果<strong>基类的析构函数不是 virtual，那么⼦类的析构函数将不会被调⽤</strong>，⼦类的资源没有正确是释放，因此造成内存泄露。这里指的是在构造函数中new定义了堆内存，而在析构函数中定义了释放。而子类析构函数的失效会导致new没有对应的delete。</li>
</ul>
<h3 id="12-子类可以继承父类的哪些东西？"><a href="#12-子类可以继承父类的哪些东西？" class="headerlink" title="12.子类可以继承父类的哪些东西？"></a>12.子类可以继承父类的哪些东西？</h3><p>  1.成员变量：子类继承了父类的所有成员变量，但是继承的可访问性（即从哪里可以访问这些成员）取决于这些成员的访问修饰符（public, protected, private）：</p>
<ul>
<li><strong>public继承</strong>：基类的public成员在派生类中保持public，protected成员在派生类中保持protected，而<strong>private成员则不可访问</strong>。</li>
<li><strong>protected继承</strong>：基类的public和protected成员在派生类中都变为protected，private成员不可访问。</li>
<li><strong>private继承</strong>：基类的所有成员（public和protected）在派生类中都变为private，基类的private成员仍然不可访问。</li>
</ul>
<p>2.子类继承了父类的所有成员函数，但同样，这些函数的可访问性由继承类型和原有的访问修饰符决定。此外，派生类可以覆盖（override）基类中的<strong>虚函数</strong>，提供特定于派生类的行为。<br>3.构造函数与析构函数<br>虽然构造函数和析构函数不被“继承”（因为它们不可以被直接调用或覆盖），但构造子类对象时会自动调用基类的构造函数，析构时同样会调用基类的析构函数。子类可以通过初始化列表显式调用特定的基类构造函数。<br>4. 友元函数<br><strong>友元关系不被继承</strong>。如果基类有友元函数，这些函数对派生类的成员没有特殊的访问权限，<strong>除非派生类独立声明它们为友元</strong>。<br>5. 静态成员<br>静态成员被类的所有实例共享，包括派生类的实例。派生类的实例可以访问基类的静态成员，前提是这些成员对派生类是可见的（即它们不是私有的）。</p>
<h3 id="13-什么是野指针"><a href="#13-什么是野指针" class="headerlink" title="13.什么是野指针"></a>13.什么是野指针</h3><p>野指针是指指向已经被释放的或无效的内存地址的指针。<br><strong>产生的情况：</strong></p>
<ul>
<li><p>1.释放后没有置空指针：</p>
<pre><code>int* ptr = new int;
delete ptr;
// 此时 ptr 成为野指针，因为它仍然指向已经被释放的内存
ptr = nullptr; // 避免野指针，应该将指针置为 nullptr 或赋予新的有效地址
</code></pre>
</li>
<li><p>2.返回局部变量的指针</p>
<pre><code>int* createInt() &#123;
int x = 10;
return &amp;x; // x 是局部变量，函数结束后 x 被销毁，返回的指针成为野指针
&#125;
// 在使⽤返回值时可能引发未定义⾏为
</code></pre>
</li>
<li><p>3.释放内存后没有调整指针</p>
<pre><code>int* ptr = new int;
// 使⽤ ptr 操作内存
delete ptr;
// 此时 ptr 没有被置为 nullptr 或新的有效地址，成为ᰀ指针
// 避免：delete ptr; ptr = nullptr;
</code></pre>
</li>
<li><p>4.函数参数指针被释放</p>
<pre><code>void foo(int* ptr) &#123;
// 操作 ptr
delete ptr;
&#125;
int main() &#123;
int* ptr = new int;
foo(ptr);
// 在 foo 函数中 ptr 被释放，但在 main 函数中仍然可⽤，成为ᰀ指针
// 避免：在 foo 函数中不要释放调⽤⽅传递的指针
&#125;
</code></pre>
</li>
</ul>
<p><strong>如何避免野指针</strong></p>
<ul>
<li>在只放内存后将指针置位nullptr</li>
<li>避免返回局部变量的指针</li>
<li>使用智能指针</li>
<li>注意函数参数的声明周期</li>
</ul>
<h3 id="14-野指针与悬浮指针的区别"><a href="#14-野指针与悬浮指针的区别" class="headerlink" title="14.野指针与悬浮指针的区别"></a>14.野指针与悬浮指针的区别</h3><p><strong>野指针</strong>是指向已经被释放或者⽆效的内存地址的指针。通常由于指针指向的内存被释放，但指针本身没有被置为nullptr 或者重新分配有效的内存，导致指针<font style ="color:red">仍然包含之前的内存地址</font>。使⽤野指针进⾏访问会导致未定义⾏为，可能引发程序崩溃、数据损坏等问题。<br><strong>悬浮指针</strong>是指向<font style ="color:red">已经被销毁的对象的引⽤</font>。当函数返回⼀个局部变量的引⽤，⽽调⽤者使⽤该引⽤时，就可能产⽣悬浮引⽤。访问悬浮引⽤会导致未定义⾏为，因为引⽤指向的对象已经被销毁，数据不再有效</p>
<p>区别：<br><strong>关联对象类型：</strong></p>
<ul>
<li>野指针涉及<strong>指针</strong>类型。</li>
<li>悬浮指针涉及<strong>引⽤</strong>类型。</li>
</ul>
<p><strong>问题表现：</strong></p>
<ul>
<li>野指针可能导致访问已释放或⽆效内存，引发崩溃或数据损坏。</li>
<li>悬浮指针可能导致访问已销毁的对象，引发未定义⾏为。</li>
</ul>
<h3 id="15-C-面向对象的三大特性："><a href="#15-C-面向对象的三大特性：" class="headerlink" title="15.C++面向对象的三大特性："></a>15.C++面向对象的三大特性：</h3><p><em><strong>访问权限</strong></em><br>在类的内部（定义类的代码内部），⽆论成员被声明为 public、protected 还是 private，<strong>都是可以互相访问的</strong>，没有访问权限的限制。<br>在类的外部，只能通过对象来访问成员，<strong>同时只能访问public属性的成员</strong>，不能访问private、protected属性的成员。<br><em><strong>1.继承</strong></em><br>可以让某些对象获得另一个类型对象的属性和方法。它可以使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展。<br><strong>继承的三种常见方式</strong></p>
<ul>
<li>1.public继承</li>
<li>2.protected继承</li>
<li>3.private继承</li>
</ul>
<p>关系图如表所示：</p>
<table>
<thead>
<tr>
<th>类成员&#x2F;继承方式</th>
<th>public继承</th>
<th>protected继承</th>
<th>private继承</th>
</tr>
</thead>
<tbody><tr>
<td>基类的public成员</td>
<td>派生类public</td>
<td>派生类protected成员</td>
<td>派生类private成员</td>
</tr>
<tr>
<td>基类proteceted成员</td>
<td>派生类protected</td>
<td>派生类的protected成员</td>
<td>派生类private成员</td>
</tr>
<tr>
<td>基类的private成员</td>
<td>派生类不可见</td>
<td>派生类不可见</td>
<td>派生类不可见</td>
</tr>
</tbody></table>
<p><em><strong>2.封装</strong></em><br>数据和代码捆绑在⼀起，避免外界⼲扰和不确定性访问。<strong>把客观事物封装成抽象的类</strong>，并且类可以把⾃⼰的数据和⽅法只让可信的类或者对象操作，对不可信的进⾏信息隐藏，例如：将公共的数据或⽅法使⽤public修饰，⽽不希望被访问的数据或⽅法采⽤private修饰<br><em><strong>3.多态</strong></em><br>同⼀事物表现出不同事物的能⼒，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣不同的⾏为（重载实现编译时多态，虚函数实现运⾏时多态）。<br>多态性是允许你将⽗对象设置成为和⼀个或更多的他的⼦对象相等的技术，赋值之后，⽗对象就可以根据当前赋值给它的⼦对象的特性以不同的⽅式运作。<br><strong>实现多态两种方式：</strong></p>
<ul>
<li>1.覆盖override：是指⼦类重新定义⽗类的虚函数的做法</li>
<li>2.重载overload：允许存在多个同名函数，只是这些函数的参数不同。</li>
</ul>
<h3 id="16-多重继承"><a href="#16-多重继承" class="headerlink" title="16.多重继承"></a>16.多重继承</h3><p>⼀个类可以从多个基类（⽗类）继承属性和⾏为。在C++等⽀持多重继承的语⾔中，⼀个派⽣类可以同时拥有多个基类。<br>菱形继承：B继承A，C继承A，D多重继承B与A，这时在D中调用A的函数就会带来歧义。<br>解决办法：让B虚继承A，C虚继承A</p>
<h3 id="17-重载与重写的区别"><a href="#17-重载与重写的区别" class="headerlink" title="17.重载与重写的区别"></a>17.重载与重写的区别</h3><ul>
<li><p><strong>重载</strong>:重载是指在同⼀作⽤域内，使⽤相同的函数名但具有不同的参数列表或类型，使得同⼀个函数名可以有<strong>多个版本</strong>。</p>
<pre><code>int add(int a, int b) &#123;
return a + b;
&#125;
double add(double a, double b) &#123;
return a + b;
&#125;
</code></pre>
</li>
<li><p><strong>重写</strong>：重写是指派⽣类（⼦类）重新实现（覆盖）基类（⽗类）中的虚函数，以提供特定于派⽣类的实现。重写是⾯向对象编程中的多态性的⼀种体现，主要涉及基类和派⽣类之间的关系，⽤于实现运⾏时多态。</p>
<pre><code>class Base &#123;
public:
virtual void print() &#123;
cout &lt;&lt; &quot;Base class&quot; &lt;&lt; endl;
&#125;
&#125;;
class Derived : public Base &#123;
public:
void print() override &#123;
cout &lt;&lt; &quot;Derived class&quot; &lt;&lt; endl;
&#125;
&#125;;
</code></pre>
</li>
</ul>
<h3 id="18-虚函数和虚函数表"><a href="#18-虚函数和虚函数表" class="headerlink" title="18.虚函数和虚函数表"></a>18.虚函数和虚函数表</h3><ul>
<li>1.<strong>虚函数</strong>：C++中的虚函数的作⽤主要是实现了多态的机制。虚函数允许在派⽣类中重新新定义基类中定义的函数，使得通过基类指针或引⽤调⽤的函数在运⾏时根据实际对象类型来确定。这样的机制被称为动态绑定或运⾏时多态。在基类中，通过在函数声明前⾯加上 virtual 关键字，可以将其声明为虚函数。派⽣类可以重新定义虚函数，如果派⽣类不重新定义，<strong>则会使⽤基类中的实现</strong>。</li>
<li>2.<strong>虚函数表</strong>：虚函数的实现通常依赖于⼀个被称为虚函数表（虚表）的数据结构。<strong>每个类（包括抽象类）都有⼀个虚表</strong>，其中包含了该类的<strong>虚函数的地址</strong>。每个对象都包含⼀个指向其类的虚表的指针，这个指针被称为虚指针（vptr）。</li>
</ul>
<h3 id="19-虚函数和纯虚函数的区别"><a href="#19-虚函数和纯虚函数的区别" class="headerlink" title="19.虚函数和纯虚函数的区别"></a>19.虚函数和纯虚函数的区别</h3><p>  1.虚函数：</p>
<ul>
<li>1.有实现</li>
<li>2.可选择是否实现：如果不实现就直接使用基类的默认实现</li>
<li>3.允许实例化</li>
<li>4.调用靠对象类型决定</li>
<li>5.virtual关键字来声明，但最后不要包含&#x3D;0</li>
</ul>
<p>2.纯虚函数：</p>
<ul>
<li><p>1.没实现</p>
</li>
<li><p>2.强制覆盖：派⽣类必须提供纯虚函数的具体实现，否则它们也会成为抽象类。</p>
</li>
<li><p>3.禁止实例化</p>
</li>
<li><p>4.最后使用&#x3D;0来声明</p>
<pre><code>class AbstractBase &#123;
public:
// 纯虚函数，没有具体实现
virtual void pureVirtualFunction() = 0;
// 普通成员函数可以有具体实现
void commonFunction() &#123;
// 具体实现
&#125;
&#125;;
</code></pre>
</li>
</ul>
<h3 id="20-抽象类和纯虚函数的区别"><a href="#20-抽象类和纯虚函数的区别" class="headerlink" title="20.抽象类和纯虚函数的区别"></a>20.抽象类和纯虚函数的区别</h3><ul>
<li><p>1.抽象类：抽象类是不能被实例化的类，它存在的主要⽬的是为了提供⼀个接⼝，供派⽣类继承和实现。抽象类中<strong>可以包含普通的成员函数</strong>、数据成员和构造函数，但它必须包含 <strong>⾄少⼀个</strong> 纯虚函数。即在声明中使⽤ virtual 关键字并赋予函数⼀个 &#x3D; 0 的纯虚函数。</p>
<pre><code>class AbstractShape &#123;
public:
// 纯虚函数，提供接⼝
virtual void draw() const = 0;
// 普通成员函数
void commonFunction() &#123;
// 具体实现
&#125;
&#125;;
</code></pre>
</li>
<li><p>2.纯虚函数是在抽象类中声明的虚函数，它没有具体的实现，只有函数的声明。通过在函数声明的末尾使⽤ &#x3D; 0 ，可以将虚函数声明为纯虚函数。派⽣类必须实现抽象类中的纯虚函数，否则它们也会成为抽象类。</p>
<pre><code>class AbstractShape &#123;
public:
// 纯虚函数
virtual void draw() const = 0;
&#125;;
</code></pre>
</li>
</ul>
<h3 id="21-为什么不能有虚构造函数"><a href="#21-为什么不能有虚构造函数" class="headerlink" title="21.为什么不能有虚构造函数"></a>21.为什么不能有虚构造函数</h3><p>构造函数不能是虚的，原因在于：</p>
<ul>
<li>1.对象的构造过程：构造函数的任务是初始化对象。在调用任何构造函数之前，对象的内存必须先被分配。<strong>虚函数工作依赖于对象的虚表（vtable），而在构造函数运行之前，虚表指针还未被设置</strong>，因此在对象构造过程中不能使用虚机制。</li>
<li>2.确定性：构造函数用于创建新对象。在 C++ 中，<strong>虚函数的调用依赖于对象的动态类型。然而，在构造阶段，对象的动态类型是正在被构造的类。</strong>因此，没有逻辑上的需求或可能性去有一个“虚构造函数”，因为我们总是知道应该调用哪个构造函数。</li>
<li>3.设计决策：如果构造函数可以是虚的，这将意味着通过基类的构造函数可以创建派生类的对象，这违背了对象创建的基本原则，即构造函数是明确地为创建特定类型的对象而设计。</li>
</ul>
<h3 id="22-深拷贝与浅拷贝"><a href="#22-深拷贝与浅拷贝" class="headerlink" title="22.深拷贝与浅拷贝"></a>22.深拷贝与浅拷贝</h3><ul>
<li>1.深拷贝：深拷⻉是对对象的<strong>完全独⽴复制</strong>，包括对象内部动态分配的资源。在深拷⻉中，不仅复制<strong>对象的值</strong>，还会复制对象<strong>所指向的堆上的数据</strong>。</li>
<li>2.浅拷贝：浅拷⻉<strong>仅复制对象的值</strong>，⽽不涉及对象内部动态分配的资源。在浅拷⻉中，新对象和原对象<strong>共享相同的资源</strong>，⽽不是复制⼀份新的资源。</li>
</ul>
<p><strong>例子来区分深拷贝与浅拷贝的使用情况</strong>：</p>
<ul>
<li><p>1.<strong>基本类不会改变</strong>：<br>因为，基本类型赋值时，赋的是数据（所以，不存在深拷贝和浅拷贝的问题）。<br>如：</p>
<pre><code>Var x = 100;
Var y = x; //此时x和y都是100;
</code></pre>
<p> 如果要改变y的值，x的值不会改变。</p>
</li>
<li><p>2.引用类型赋值用的就是浅拷贝（因为只复制了地址）</p>
</li>
</ul>
<h3 id="23-智能指针"><a href="#23-智能指针" class="headerlink" title="23.智能指针"></a>23.智能指针</h3><p>智能指针：用于管理动态内存的对象，目的是在避免内存泄漏和方便资源管理</p>
<ul>
<li>1.unique_ptr:独占智能指针<br>独占所有权的智能指针：同一个时间内只有一个unique_ptr可以拥有对象的所有权。当unique_ptr被销毁时，<font style= "color:red">它指向的对象也会被自动销毁。</font></li>
<li>2.shared_ptr:共享智能指针<br>是一种共享所有权的智能指针，多个shared_ptr可以<font style= "color:red">同时拥有同一个对象的所有权</font>。引用计数被用来追踪有多少个shared_ptr共享同一个资源，当没有shared_ptr指向对象时，对象将被自动销毁。</li>
<li>3.weak_ptr:弱引用智能指针<br>是一种非拥有性的智能指针。它指向由某个<strong>shared_ptr管理</strong>的对象，但不会增加对象的引用计数。这允许weak_ptr访问资源而不阻止其被销毁。它主要用来解决shared_ptr的循环引用问题。</li>
</ul>
<h3 id="23-STL"><a href="#23-STL" class="headerlink" title="23.STL"></a>23.STL</h3><p>C++ STL（Standard Template Library，标准模板库）是C++语言的一个非常核心的组成部分，它提供了一系列的模板类和模板函数。这些模板类和函数可以帮助程序员更高效地处理数据结构和算法操作，而无需从头开始编写所有代码。<br>包含以下4个组成部分：<br>1.容器</p>
<ul>
<li>序列容器：如vector，list，deque</li>
<li>关联容器：set，map，multiset，multimap</li>
<li>无需容器：如unordered_set, unordered_map, unordered_multiset,unordered_multimap</li>
<li>容器适配器（如stack, queue, priority_queue）<br>2.算法：例如sort，find<br>3.迭代器<br>4.函数对象</li>
</ul>
<h3 id="24-vector与list的区别："><a href="#24-vector与list的区别：" class="headerlink" title="24. vector与list的区别："></a>24. vector与list的区别：</h3><ul>
<li><ol>
<li>vector底层实现是<strong>数组</strong>；list是<strong>双向链表</strong></li>
</ol>
</li>
<li><ol start="2">
<li>vector是顺序内存,⽀持随机访问，list不⾏</li>
</ol>
</li>
<li><ol start="3">
<li>vector在中间节点进⾏插⼊删除会导致内存拷⻉，list不会</li>
</ol>
</li>
<li><ol start="4">
<li>vector⼀次性分配好内存，不够时才进⾏翻倍扩容；list每次插⼊新节点都会进⾏内存申请</li>
</ol>
</li>
<li><ol start="5">
<li>vector随机访问性能好，插⼊删除性能差；list随机访问性能差，插⼊删除性能好</li>
</ol>
</li>
</ul>
<h3 id="25-map-amp-amp-set的区别和实现原理"><a href="#25-map-amp-amp-set的区别和实现原理" class="headerlink" title="25.map&amp;&amp;set的区别和实现原理"></a>25.map&amp;&amp;set的区别和实现原理</h3><p>map内部实现了⼀个红⿊树<font style= "color:red">（红⿊树是⾮严格平衡的⼆叉搜索树，⽽AVL是严格平衡⼆叉搜索树）</font>，红⿊树有⾃动排序的功能，因此map内部所有元素都是有序的，红⿊树的每⼀个节点都代表着map的⼀个元素。因此，对于map进⾏的查找、删除、添加等⼀系列的操作都相当于是对红⿊树进⾏的操作。<br>map中的元素是按照⼆叉树（⼜名⼆叉查找树、⼆叉排序树）存储的，特点就是左⼦树上所有节点的键值都⼩于根节点的键值，右⼦树所有节点的键值都⼤于根节点的键值。使⽤中序遍历可将键值按照从⼩到⼤遍历出来。</p>
<p><em><strong>共同点：</strong></em><br>都是C++的关联容器,只是通过它提供的接⼝对⾥⾯的元素进⾏访问，底层都是采⽤红⿊树实现。<br><em><strong>不同点：</strong></em><br>set：⽤来判断某⼀个元素是不是在⼀个组⾥⾯。<br>map：映射，相当于字典，把⼀个值映射成另⼀个值，可以创建字典。<br><em><strong>优点：</strong></em><br>查找某一个数的时间为O(logn)；便利时候采用iterator<br><em><strong>缺点：</strong></em><br>每次插⼊值的时候，都需要调整红⿊树，效率有⼀定影响。</p>
<h3 id="26-map与unordered-map的区别"><a href="#26-map与unordered-map的区别" class="headerlink" title="26.map与unordered_map的区别"></a>26.map与unordered_map的区别</h3><p>map中元素是⼀些key-value对，关键字起索引作⽤，值表示和索引相关的数据。<br><em><strong>底层实现：</strong></em></p>
<ul>
<li>map底层是基于红⿊树实现的，因此map内部元素排列是<font style= "color:red">有序的</font>。 </li>
<li>unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱⽆序的。</li>
</ul>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul>
<li><strong>优点</strong><br>有序性，这是map结构最⼤的优点，其元素的有序性在很多应⽤中都会简化很多的操作。 map的查找、删除、增加等⼀系列操作时间复杂度稳定，都为O(logn)。</li>
<li><strong>缺点</strong><br>查找、删除、增加等操作平均时间复杂度较慢，与n相关。</li>
</ul>
<h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><ul>
<li><strong>优点</strong><br>查找、删除、添加的速度快，时间复杂度为常数级O(1）</li>
<li><strong>缺点</strong><br>因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占⽤率⾼。<br>unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(1)，取决于哈希函数。极端情况下可能为O(n)。</li>
</ul>
<h3 id="27-迭代器"><a href="#27-迭代器" class="headerlink" title="27.迭代器"></a>27.迭代器</h3><p>迭代器为不同类型的容器提供了统⼀的访问接⼝， 隐藏了底层容器的具体实现细节，允许开发者使⽤⼀致的语法来操作不同类型的容器。</p>
<ul>
<li><strong>序列容器</strong>vector，deque来说，使⽤erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动⼀位，erase返回下⼀个有效的迭代器。</li>
<li><strong>关联容器</strong>map，set来说，使⽤了erase后，当前元素的迭代器失效，但是其结构是红⿊树，删除当前元素，不会影响下⼀个元素的迭代器，所以在调⽤erase之前，记录下⼀个元素的迭代器即可。</li>
<li>list来说，它使⽤了不连续分配的内存，并且它的erase⽅法也会返回下⼀个有效的迭代器，因此上⾯两种⽅法都可以使⽤。</li>
</ul>
<h3 id="28-最抽象的一题：C-11的新特性有哪些"><a href="#28-最抽象的一题：C-11的新特性有哪些" class="headerlink" title="28.最抽象的一题：C++11的新特性有哪些"></a>28.最抽象的一题：C++11的新特性有哪些</h3><p>1.语法改进<br>（1）统⼀的初始化⽅法<br>（2）成员变量默认初始化<br>（3）auto关键字： 允许编译器⾃动推断变ᰁ的类型，减少类型声明的冗余。<br>（4）decltype 求表达式的类型<br>（5）智能指针 std::shared_ptr 和 std::unique_ptr<br>（6）空指针 nullptr: 提供了明确表示空指针的关键字，替代了传统的 NULL 。<br>（7）基于范围的for循环: 简化遍历容器元素的语法<br>（8）右值引⽤和move语义 引⼊右值引⽤和移动构造函数，允许⾼效地将资源从⼀个对象移动到另⼀个对象，提⾼性能。<br>2.标准库扩充<br>（9）⽆序容器（哈希表） ⽤法和功能同map⼀模⼀样，区别在于哈希表的效率更⾼<br>（10）正则表达式 可以认为正则表达式实质上是⼀个字符串，该字符串描述了⼀种特定模式的字符串<br>（11）Lambda表达式： 允许在代码中定义匿名函数</p>
<h3 id="29-为什么析构函数用虚函数好一点"><a href="#29-为什么析构函数用虚函数好一点" class="headerlink" title="29.为什么析构函数用虚函数好一点"></a>29.为什么析构函数用虚函数好一点</h3><p>当基类指针指向⼦类对象时，如果&#x3D;&#x3D;基类的析构函数不是 virtual&#x3D;&#x3D;，那么⼦类的析构函数将不会被调⽤，⼦类的资源没有正确是释放，因此造成内存泄露。这里指的是在构造函数中new定义了堆内存，而在析构函数中定义了释放。而子类析构函数的失效会导致new没有对应的delete。</p>
<h3 id="30-lambda表达式"><a href="#30-lambda表达式" class="headerlink" title="30.lambda表达式"></a>30.lambda表达式</h3><p><strong>lambda表达式基本语法</strong>：</p>
<pre><code>  [capture](parameters) -&gt; return_type &#123; body &#125;
</code></pre>
<ul>
<li>capture：捕获列表，指定哪些外部变量可以在Lambda表达式中使用。</li>
<li>parameters：参数列表，类似于函数的参数列表。</li>
<li>return_type：返回类型，可以省略，如果编译器能够推导出返回类型。</li>
<li>body：函数体，包含要执行的代码。<br>只有 [capture] &#x3D;&#x3D;捕获列表&#x3D;&#x3D;和 {body } &#x3D;&#x3D;函数体&#x3D;&#x3D;是必选的</li>
</ul>
<p><strong>捕获列表</strong>：</p>
<ul>
<li>[ ]：不捕获任何变量。</li>
<li>[&#x3D;]：按值捕获外部作用域中的所有变量。</li>
<li>[&amp;]：按引用捕获外部作用域中的所有变量。</li>
<li>[x]：按值捕获变量x。</li>
<li>[&amp;x]：按引用捕获变量x。</li>
<li>[&#x3D;, &amp;y]：按值捕获外部作用域中的所有变量，但按引用捕获变量y。</li>
<li>[&amp;, x]：按引用捕获外部作用域中的所有变量，但按值捕获变量x。</li>
</ul>
<p><strong>实例</strong>：<br><strong>按值捕获</strong>（[&#x3D;] 或 [x]）：按值捕获外部变量的当前值，Lambda表达式内无法修改这些变量。<br><strong>按引用捕获</strong>（[&amp;] 或 [&amp;x]）：按引用捕获外部变量，Lambda表达式内可以&#x3D;&#x3D;修改这些变量&#x3D;&#x3D;。<br><strong>隐式捕获</strong>（[&#x3D;] 或 [&amp;]）：捕获所有外部变量，[&#x3D;]按值捕获，[&amp;]按引用捕获。<br><strong>混合捕获</strong>：可以同时使用按值和按引用捕获特定的外部变量，如 [&#x3D;, &amp;x] 或 [&amp;, x]。</p>
<ul>
<li><p>1.基本lambda表达式：不捕获任何变量</p>
<pre><code>#include &lt;iostream&gt;

int main() &#123;
auto add = [](int a, int b) &#123;
      return a + b;
&#125;;

std::cout &lt;&lt; &quot;3 + 4 = &quot; &lt;&lt; add(3, 4) &lt;&lt; std::endl;
return 0;
&#125;
</code></pre>
</li>
<li><p>2.捕获外部变量：</p>
<pre><code>#include &lt;iostream&gt;

int main() &#123;
int x = 10;
int y = 20;

auto add = [x, y]() &#123;
      return x + y;
&#125;;

std::cout &lt;&lt; &quot;x + y = &quot; &lt;&lt; add() &lt;&lt; std::endl; // 输出: x + y = 30
return 0;
&#125;
</code></pre>
</li>
<li><p>3.按引用捕获变量</p>
<pre><code>      #include &lt;iostream&gt;

      int main() &#123;
      int x = 10;
      int y = 20;

      auto add_and_modify = [&amp;x, &amp;y]() &#123;
            x += 5;
            y += 5;
            return x + y;
      &#125;;

      std::cout &lt;&lt; &quot;x + y = &quot; &lt;&lt; add_and_modify() &lt;&lt; std::endl; // 输出: x + y = 35
      std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; std::endl;   // 输出: x = 15, y = 25
      return 0;
      &#125;
</code></pre>
</li>
</ul>
<h3 id="31-C语言与C-的区别"><a href="#31-C语言与C-的区别" class="headerlink" title="31.C语言与C++的区别"></a>31.C语言与C++的区别</h3><ul>
<li>1.面向对象编程<ul>
<li><strong>C语言</strong>：不支持面向对象编程，没有类、对象、继承、封装和多态等概念。</li>
<li><strong>C++语言</strong>：支持面向对象编程，引入了类、对象、继承、封装和多态等概念，使得代码复用性和可维护性大大提高。</li>
</ul>
</li>
<li>2.数据抽象和封装<ul>
<li><strong>C语言</strong>：主要通过结构体（struct）和函数来实现数据抽象。没有访问控制机制。</li>
<li><strong>C++语言</strong>：通过类和对象来实现数据抽象和封装。支持公有（public）、私有（private）和保护（protected）等访问控制机制。</li>
</ul>
</li>
</ul>
<h3 id="32-继承的内在实现"><a href="#32-继承的内在实现" class="headerlink" title="32.继承的内在实现"></a>32.继承的内在实现</h3><ul>
<li><p><strong>内存布局</strong><br>在继承的情况下，派生类对象的内存布局通常包括基类部分和派生类部分。&#x3D;&#x3D;基类部分在内存中的位置通常在派生类部分之前&#x3D;&#x3D;。一般内存布局如下：</p>
<pre><code>+------------------+
| base_data        |  // 来自 Base 类
+------------------+
| derived_data     |  // 来自 Derived 类
+------------------+
</code></pre>
</li>
<li><p>虚函数和虚函数表（vtable）<br>虚函数是C++中实现多态性的一种机制。当基类中有虚函数时，编译器会为类创建一个虚函数表（vtable）。虚函数表包含了类的虚函数指针。每个对象都有一个&#x3D;&#x3D;指向该表的指针&#x3D;&#x3D;，称为虚函数指针（vptr）。如果出现了B继承A，C继承B的情况发生。也是只有一个虚函数表存在，里面包含类ABC。</p>
</li>
</ul>
<h3 id="33-被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？"><a href="#33-被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？" class="headerlink" title="33.被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？"></a>33.被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？</h3><p>一种类中声明，一种通过子类中调用基类的函数</p>
<ul>
<li><p><strong>调用父类的同名函数</strong>：可以使用基类名加上作用域解析运算符来调用父类的同名函数。例如：</p>
<pre><code>class Base &#123;
public:
void function() &#123;
      cout &lt;&lt; &quot;This is the Base class function&quot; &lt;&lt; endl;
&#125;
&#125;;

class Derived : public Base &#123;
public:
void function() &#123;
      cout &lt;&lt; &quot;This is the Derived class function&quot; &lt;&lt; endl;
&#125;

void callBaseFunction() &#123;
      Base::function(); // 调用父类的同名函数
&#125;
&#125;;

Derived d;
d.function(); // 调用子类的同名函数
d.callBaseFunction(); // 调用父类的同名函数
</code></pre>
</li>
</ul>
<p>在上述示例中，Derived类中定义了一个与Base类同名的函数function。通过使用&#x3D;&#x3D;Base::function()&#x3D;&#x3D;，我们可以在子类中调用父类的同名函数。</p>
<ul>
<li><p>访问父类的同名成员变量：可以使用作用域解析运算符来访问父类的同名成员变量。例如：</p>
<pre><code>class Base &#123;
public:
int x;

void print() &#123;
      cout &lt;&lt; &quot;Base x: &quot; &lt;&lt; x &lt;&lt; endl;
&#125;
&#125;;

class Derived : public Base &#123;
public:
int x;

void print() &#123;
      cout &lt;&lt; &quot;Derived x: &quot; &lt;&lt; x &lt;&lt; endl; // 访问子类的同名成员变量
      cout &lt;&lt; &quot;Base x: &quot; &lt;&lt; Base::x &lt;&lt; endl; // 访问父类的同名成员变量
&#125;
&#125;;

Derived d;
d.x = 10;
d.Base::x = 20;
d.print();
</code></pre>
</li>
</ul>
<p>在上述示例中，Derived类和Base类都定义了一个同名的成员变量x。通过使用&#x3D;&#x3D;Base::x&#x3D;&#x3D;，我们可以在子类中访问父类的同名成员变量。</p>
<h3 id="34-拷贝构造函数"><a href="#34-拷贝构造函数" class="headerlink" title="34.拷贝构造函数"></a>34.拷贝构造函数</h3><p>拷贝构造函数的作用是<strong>创建一个对象的副本</strong>。<br>它在以下情况下被调用：</p>
<ul>
<li>1.对象的复制：当使用一个同类对象来初始化另一个同类对象时，拷贝构造函数被调用。例如，通过复制一个对象来创建一个新对象。</li>
<li>2.参数传递：当将对象作为参数传递给函数时，拷贝构造函数用于创建参数的副本。</li>
<li>3.返回值：当函数返回一个对象时，拷贝构造函数用于创建返回值的副本。</li>
</ul>
<p>需要自定义拷贝构造函数的情况：</p>
<ul>
<li>浅拷贝不够：如果类中有指针成员或资源（如文件句柄）需要进行深度拷贝，以防止多个对象共享同一资源。否则，当一个对象销毁时，共享的资源可能会被释放，从而导致其他对象的资源变为无效。</li>
<li>防止浅拷贝：如果类没有指针成员或资源，但是你希望禁止浅拷贝操作，以确保每个对象都有其自己的独立副本，而不是共享相同的数据。</li>
<li>高效率要求：有时候默认的拷贝构造函数可能不够高效，例如当类中有大量的数据或复杂的操作时。在这种情况下，自定义拷贝构造函数可以实现更高效的对象复制。</li>
</ul>
<p>例子：</p>
<pre><code>  #include &lt;iostream&gt;

  class MyClass &#123;
  public:
  int* data; // 指针成员

  // 默认构造函数
  MyClass() : data(nullptr) &#123;&#125;

  // 自定义拷贝构造函数
  MyClass(const MyClass&amp; other) &#123;
        // 执行深拷贝
        if (other.data != nullptr) &#123;
              data = new int(*other.data);
        &#125; else &#123;
              data = nullptr;
        &#125;
  &#125;

  // 析构函数
  ~MyClass() &#123;
        delete data; // 释放堆内存
  &#125;
  &#125;;

  int main() &#123;
  MyClass obj1;
  obj1.data = new int(10);

  MyClass obj2(obj1); // 使用拷贝构造函数进行深拷贝

  std::cout &lt;&lt; *obj1.data &lt;&lt; std::endl; // 输出: 10
  std::cout &lt;&lt; *obj2.data &lt;&lt; std::endl; // 输出: 10

  delete obj1.data;

  std::cout &lt;&lt; *obj2.data &lt;&lt; std::endl; // 输出: 10，仍然有效
  return 0;
  &#125;
</code></pre>
<p>上述代码中，MyClass类中包含了一个指针成员data。为了避免多个对象共享同一个内存资源，我们在拷贝构造函数中进行了深拷贝操作，即创建一个新的内存副本并将指针指向新的内存位置。这样，obj2对象将拥有独立的data指针和副本，而不会与obj1对象共享。至于析构函数中的delete操作，则用于释放堆内存，避免内存泄漏</p>

            </div>

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2024/01/01/%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">驱动实现</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2024/01/01/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">计算机网络问题</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2024
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">caijiQAQ</a>
            
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>










<div class="post-scripts">
    
        
<script src="/js/post-helper.js"></script>

        
        
    
</div>



</body>
</html>
