<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="caijiQAQ">
    
    <title>
        
            C++面试 |
        
        学习笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"caiji-qaq.github.io","root":"/","language":"en"}
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"header_transparent":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":false,"preload":false},"code_copy":{},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":false,"min2read":false},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               学习笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">C++面试</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">caijiQAQ</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2024-01-01 09:28:41</span>
        <span class="mobile">2024-01-01 09:28</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2024-08-22 17:26:43</span>
    </span>
    
    
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h3 id="1-const关键字"><a href="#1-const关键字" class="headerlink" title="1.const关键字"></a>1.const关键字</h3><ul>
<li>1.常量指针：const修饰的时这个int指针指代的对象的不可改变性<br><strong>const</strong> int* a &#x3D;&amp;temp;</li>
<li>2.指针常量：const修饰的是p这个指针地址，也就是地址不可修改<br>int * const p &#x3D;&amp;temp;<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PicgoImage@main/img/202404161630875.png"><br>3.<strong>常量指针与指针常量的区别：</strong><br>常量指针一般const关键字在*之前，但是在指针常量中const在*之后。<br>常量指针是指针本身是常量，内容可变，但是本身地址不能变<br>指针常量是指针所指向的内容是常量，指针本身可变</li>
</ul>
<h3 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2.static关键字"></a>2.static关键字</h3><p>1.静态变量</p>
<ul>
<li>static修饰的变量是静态变量</li>
<li>作用：声明的静态变量会在程序的整个生命周期中存在，不会因为离开作用域而销毁</li>
</ul>
<p>2.静态函数</p>
<ul>
<li>static修饰的函数时静态函数</li>
<li>作用：静态函数属于类而不是类的实例，可以通过类名直接调用，而无需创建对象。</li>
<li>静态函数不能直接访问非静态成员变量或非静态成员函数。</li>
<li>作用域限制：静态函数通常只在声明它的文件中可见，其他文件不能访问。这有助于减少函数的全局可见性，从而减少命名冲突。</li>
</ul>
<p>3.静态成员变量</p>
<ul>
<li>声明在类内，定义要<strong>在类外面定义</strong></li>
<li>所有类的对象共享一个静态成员变量的副本</li>
</ul>
<p>4.静态成员函数</p>
<ul>
<li>静态成员函数不能直接访问⾮静态成员变量或⾮静态成员函数。</li>
</ul>
<h3 id="3-define与typedef的区别"><a href="#3-define与typedef的区别" class="headerlink" title="3.define与typedef的区别"></a>3.define与typedef的区别</h3><ul>
<li>1.define是预处理指令，简单的机械替换</li>
<li>2.typedef是关键字，有类型检查功能；typedef 提供了类型安全，因为它只能用于为现有类型定义别名，而不能进行简单的文本替换。typedef会在变异其中解释和检查，而define只是简单的文本替换</li>
</ul>
<h3 id="4-inline的作用"><a href="#4-inline的作用" class="headerlink" title="4.inline的作用"></a>4.inline的作用</h3><p>正常编译一个函数的时候，编译器生成一个机器指令来调用函数，运行到的位置会将当前的程序计数器（指向下一条指令的地址）保存到栈上，并跳转到函数的地址上。但是inline声明的函数可以直接将函数直接插入到调用点，也就不再需要参数传递和栈等操作了。因此inline的函数最好是选择一些短小的函数，否则频繁调用会让代码膨胀。</p>
<h3 id="5-new与malloc的区别"><a href="#5-new与malloc的区别" class="headerlink" title="5.new与malloc的区别"></a>5.new与malloc的区别</h3><p>new</p>
<pre><code>  int* ptr = new int(10);  // 分配内存并初始化为 10
  int* array = new int[5]; // 分配一个包含 5 个整数的数组
</code></pre>
<p>  malloc</p>
<pre><code>  int* ptr = (int*) malloc(sizeof(int));
  int* array = (int*) malloc(5 * sizeof(int));
</code></pre>
<p>1.类型安全性：</p>
<ul>
<li>new 是C++的运算符，可以为对象分配内存并调⽤相应的构造函数。</li>
<li>malloc 是C语⾔库函数，只分配指定⼤⼩的内存块，不会调⽤构造函数。</li>
</ul>
<p>2.返回类型：</p>
<ul>
<li>new 返回的是具体类型的指针，⽽且不需要进⾏类型转换。</li>
<li>malloc 返回的是 void* ，需要进⾏<strong>类型转换</strong>，因为它不知道所分配内存的⽤途。</li>
</ul>
<p>3.内存分配失败时的⾏为：</p>
<ul>
<li>new 在内存分配失败时会抛出 std::bad_alloc 异常。</li>
<li>malloc 在内存分配失败时返回 NULL 。</li>
</ul>
<p>4.内存块⼤⼩：</p>
<ul>
<li>new 可以⽤于动态分配数组，并知道数组⼤⼩。</li>
<li>malloc 只是分配指定⼤⼩的内存块，不了解所分配内存块的具体⽤途。</li>
</ul>
<p>5.释放内存的⽅式：</p>
<ul>
<li>delete 会调⽤对象的析构函数，然后释放内存。</li>
<li>free 只是简单地释放内存块，不会调⽤对象的析构函数。</li>
</ul>
<h3 id="6-volatile关键字是什么"><a href="#6-volatile关键字是什么" class="headerlink" title="6.volatile关键字是什么"></a>6.volatile关键字是什么</h3><p>关键字 volatile 在 C 和 C++ 中用来告诉编译器，某个变量的值可能会在程序外部被改变，因此编译器在使用这个变量的时候不应该对其访问做任何优化。例如：<img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240416224523.png"></p>
<h3 id="7-原子操作"><a href="#7-原子操作" class="headerlink" title="7.原子操作"></a>7.原子操作</h3><p>原子操作在处理多线程或多进程环境中的数据共享和竞争条件时非常重要。如果操作是原子的，你就可以确保在任何时刻<strong>只有一个线程</strong>能修改该数据，从而避免了竞争条件和其他一些常见的多线程问题。<br>在 C++11 及之后的版本中，标准库提供了 &lt;atomic&gt; 头文件，其中包含了一系列用于执行原子操作的模板和函数。这允许你声明原子类型的变量，以及安全地在多线程环境中对这些变量进行操作。std::atomic 类型封装了一些基础类型（如 int、long 等），并提供了一系列方法来进行安全的原子操作。也就是原子操作可以保证在线程操作的时候不会出现数据竞争。</p>
<h3 id="8-struct-和class的区别"><a href="#8-struct-和class的区别" class="headerlink" title="8.struct 和class的区别"></a>8.struct 和class的区别</h3><p>通常， struct ⽤于表示⼀组<strong>相关的数据</strong>，⽽ class ⽤于表示<strong>⼀个封装了数据和操作的对象</strong>,在实际使⽤中，可以根据具体的需求选择使⽤ struct 或 class 。如果只是⽤来组织⼀些数据，⽽不涉及复杂的封装和继承关系， struct 可能更直观；如果需要进⾏封装、继承等&#x3D;&#x3D;⾯向对象编程&#x3D;&#x3D;的特性，可以选择使⽤ class 。</p>
<ul>
<li>struct 继承时默认使⽤<strong>公有</strong>继承。class 继承时默认使⽤<strong>私有</strong>继承。</li>
<li>如果struct和class都没有声明构造函数，那么编译器就会生成默认的无参数构造函数</li>
</ul>
<h3 id="9-C-内存分区"><a href="#9-C-内存分区" class="headerlink" title="9.C++内存分区"></a>9.C++内存分区</h3><p>从低地址到高地址：<br>1.代码区：存放程序代码<br>2.常量区：常量区也被称为只读区。存储常量数据，如字符串常量<br>3.全局静态区:用于存储全局变量和静态变量：寿命在整个程序<br>4.堆：用于存储动态分配内存的区域，由程序员动态分配和释放。包括使用new&#x2F;malloc+delete&#x2F;free<br>5.栈：栈⽤于存储函数的局部变量、函数参数和函数调⽤信息的区域。函数的调⽤和返回通过栈来管理</p>
<h3 id="10-栈与堆的区别"><a href="#10-栈与堆的区别" class="headerlink" title="10.栈与堆的区别"></a>10.栈与堆的区别</h3><ul>
<li>1.栈：栈上的变量⽣命周期与其所在<strong>函数的执⾏周期相同</strong></li>
<li>2.堆：堆上的变量⽣命周期<strong>由程序员显式控制</strong>，可以（使⽤ new或 malloc ）和释放（使⽤ delete 或 free ）。</li>
<li>栈上的内存分配和释放是<strong>⾃动的，速度较快</strong>。⽽堆上的内存分配和释放需要⼿动操作，<strong>速度相对较慢</strong></li>
</ul>
<h3 id="11-内存泄漏"><a href="#11-内存泄漏" class="headerlink" title="11.内存泄漏"></a>11.内存泄漏</h3><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使⽤的内存的情况。内存泄漏并⾮指内存在物理上的消失，⽽是应⽤程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因⽽造成了内存的浪费。<br>内存泄漏的分类：</p>
<ul>
<li>1.堆内存泄漏：<br>使用malloc、new等方法从堆中分配一块地址，最终导致没有释放，这块地址就会产生堆内存泄漏</li>
<li>2.系统资源泄露<br>主要指程序使⽤系统分配的资源⽐如 Bitmap,handle ,SOCKET 等没有使⽤相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运⾏不稳定。 </li>
<li>3.没有将基类的析构函数定义为虚函数<br>当基类指针指向⼦类对象时，如果<strong>基类的析构函数不是 virtual，那么⼦类的析构函数将不会被调⽤</strong>，子类的资源没有正确是释放，因此造成内存泄露。这里指的是在构造函数中new定义了堆内存，而在析构函数中定义了释放。而子类析构函数的失效会导致new没有对应的delete。</li>
</ul>
<h3 id="12-子类可以继承父类的哪些东西？"><a href="#12-子类可以继承父类的哪些东西？" class="headerlink" title="12.子类可以继承父类的哪些东西？"></a>12.子类可以继承父类的哪些东西？</h3><p>  1.成员变量：子类继承了父类的所有成员变量，但是继承的可访问性（即从哪里可以访问这些成员）取决于这些成员的访问修饰符（public, protected, private）：</p>
<ul>
<li><strong>public继承</strong>：基类的public成员在派生类中保持public，protected成员在派生类中保持protected，而<strong>private成员则不可访问</strong>。</li>
<li><strong>protected继承</strong>：基类的public和protected成员在派生类中都变为protected，private成员不可访问。</li>
<li><strong>private继承</strong>：基类的所有成员（public和protected）在派生类中都变为private，基类的private成员仍然不可访问。</li>
</ul>
<p>2.子类继承了父类的<strong>所有成员函数</strong>，但同样，这些函数的可访问性由继承类型和原有的访问修饰符决定。此外，派生类可以覆盖（override）基类中的<strong>虚函数</strong>，提供特定于派生类的行为。<br>3.构造函数与析构函数<br>虽然构造函数和析构函数不被“继承”（因为它们不可以被直接调用或覆盖），但构造子类对象时会自动调用基类的构造函数，析构时同样会调用基类的析构函数。子类可以通过初始化列表显式调用特定的基类构造函数。<br>4. 友元函数<br><strong>友元关系不被继承</strong>。如果基类有友元函数，这些函数对派生类的成员没有特殊的访问权限，<strong>除非派生类独立声明它们为友元</strong>。<br>5. 静态成员<br>静态成员被类的所有实例共享，包括派生类的实例。派生类的实例可以访问基类的静态成员，前提是这些成员对派生类是可见的（即它们不是私有的）。</p>
<h3 id="13-什么是野指针"><a href="#13-什么是野指针" class="headerlink" title="13.什么是野指针"></a>13.什么是野指针</h3><p>野指针是指指向已经被释放的或无效的内存地址的指针。<br><strong>产生的情况：</strong></p>
<ul>
<li><p>1.释放后没有置空指针：</p>
<pre><code>int* ptr = new int;
delete ptr;
// 此时 ptr 成为野指针，因为它仍然指向已经被释放的内存
ptr = nullptr; // 避免野指针，应该将指针置为 nullptr 或赋予新的有效地址
</code></pre>
</li>
<li><p>2.返回局部变量的指针</p>
<pre><code>int* createInt() &#123;
int x = 10;
return &amp;x; // x 是局部变量，函数结束后 x 被销毁，返回的指针成为野指针
&#125;
// 在使⽤返回值时可能引发未定义⾏为
</code></pre>
</li>
<li><p>3.释放内存后没有调整指针</p>
<pre><code>int* ptr = new int;
// 使⽤ ptr 操作内存
delete ptr;
// 此时 ptr 没有被置为 nullptr 或新的有效地址，成为野指针
// 避免：delete ptr; ptr = nullptr;
</code></pre>
</li>
<li><p>4.函数参数指针被释放</p>
<pre><code>void foo(int* ptr) &#123;
// 操作 ptr
delete ptr;
&#125;
int main() &#123;
int* ptr = new int;
foo(ptr);
// 在 foo 函数中 ptr 被释放，但在 main 函数中仍然可⽤，成为野指针
// 避免：在 foo 函数中不要释放调⽤⽅传递的指针
&#125;
</code></pre>
</li>
</ul>
<p><strong>如何避免野指针</strong></p>
<ul>
<li>在只放内存后将指针置位nullptr</li>
<li>避免返回局部变量的指针</li>
<li>使用智能指针</li>
<li>注意函数参数的声明周期</li>
</ul>
<h3 id="14-野指针与悬浮指针的区别"><a href="#14-野指针与悬浮指针的区别" class="headerlink" title="14.野指针与悬浮指针的区别"></a>14.野指针与悬浮指针的区别</h3><p><strong>野指针</strong>是指向&#x3D;&#x3D;已经被释放或者⽆效的内存地址&#x3D;&#x3D;的指针。通常由于指针指向的内存被释放，但指针本身没有被置为nullptr 或者重新分配有效的内存，导致指针<font style ="color:red">仍然包含之前的内存地址</font>。使⽤野指针进⾏访问会导致未定义⾏为，可能引发程序崩溃、数据损坏等问题。<br><strong>悬浮指针</strong>是指向<font style ="color:red">已经被销毁的对象的引⽤</font>。当函数返回⼀个局部变量的引⽤，⽽调⽤者使⽤该引⽤时，就可能产⽣悬浮引⽤。访问悬浮引⽤会导致未定义⾏为，因为引⽤指向的对象已经被销毁，数据不再有效</p>
<p>区别：<br><strong>关联对象类型：</strong></p>
<ul>
<li>野指针涉及<strong>指针</strong>类型。</li>
<li>悬浮指针涉及<strong>引⽤</strong>类型。</li>
</ul>
<p><strong>问题表现：</strong></p>
<ul>
<li>野指针可能导致访问已释放或⽆效内存，引发崩溃或数据损坏。</li>
<li>悬浮指针可能导致访问&#x3D;&#x3D;已销毁的对象&#x3D;&#x3D;，引发未定义⾏为。</li>
</ul>
<h3 id="15-C-面向对象的三大特性："><a href="#15-C-面向对象的三大特性：" class="headerlink" title="15.C++面向对象的三大特性："></a>15.C++面向对象的三大特性：</h3><p><em><strong>访问权限</strong></em><br>在类的内部（定义类的代码内部），⽆论成员被声明为 public、protected 还是 private，<strong>都是可以互相访问的</strong>，没有访问权限的限制。<br>在类的外部，只能通过对象来访问成员，<strong>同时只能访问public属性的成员</strong>，不能访问private、protected属性的成员。<br><em><strong>1.继承</strong></em><br>可以让某些对象获得另一个类型对象的属性和方法。它可以使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展。<br><strong>继承的三种常见方式</strong></p>
<ul>
<li>1.public继承</li>
<li>2.protected继承</li>
<li>3.private继承</li>
</ul>
<p>关系图如表所示：</p>
<table>
<thead>
<tr>
<th>类成员&#x2F;继承方式</th>
<th>public继承</th>
<th>protected继承</th>
<th>private继承</th>
</tr>
</thead>
<tbody><tr>
<td>基类的public成员</td>
<td>派生类public</td>
<td>派生类protected成员</td>
<td>派生类private成员</td>
</tr>
<tr>
<td>基类proteceted成员</td>
<td>派生类protected</td>
<td>派生类的protected成员</td>
<td>派生类private成员</td>
</tr>
<tr>
<td>基类的private成员</td>
<td>派生类不可见</td>
<td>派生类不可见</td>
<td>派生类不可见</td>
</tr>
</tbody></table>
<p><em><strong>2.封装</strong></em><br>数据和代码捆绑在⼀起，避免外界⼲扰和不确定性访问。<strong>把客观事物封装成抽象的类</strong>，并且类可以把⾃⼰的数据和⽅法只让可信的类或者对象操作，对不可信的进⾏信息隐藏，例如：将公共的数据或⽅法使⽤public修饰，⽽不希望被访问的数据或⽅法采⽤private修饰<br><em><strong>3.多态</strong></em><br>同⼀事物表现出不同事物的能⼒，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣不同的⾏为（重载实现编译时多态，虚函数实现运⾏时多态）。<br>多态性是允许你将⽗对象设置成为和⼀个或更多的他的⼦对象相等的技术，赋值之后，⽗对象就可以根据当前赋值给它的⼦对象的特性以不同的⽅式运作。<br><strong>实现多态两种方式：</strong></p>
<ul>
<li>1.覆盖override：是指⼦类重新定义⽗类的<strong>虚函数</strong>的做法</li>
<li>2.重载overload：允许存在多个同名函数，只是这些函数的参数不同。</li>
</ul>
<h3 id="16-多重继承"><a href="#16-多重继承" class="headerlink" title="16.多重继承"></a>16.多重继承</h3><p>⼀个类可以从多个基类（⽗类）继承属性和⾏为。在C++等⽀持多重继承的语⾔中，⼀个派⽣类可以同时拥有多个基类。<br>菱形继承：B继承A，C继承A，D多重继承B与A，这时在D中调用A的函数就会带来歧义。<br>解决办法：让B虚继承A，C虚继承A</p>
<h3 id="17-重载与重写的区别"><a href="#17-重载与重写的区别" class="headerlink" title="17.重载与重写的区别"></a>17.重载与重写的区别</h3><ul>
<li><p><strong>重载</strong>:重载是指在同⼀作⽤域内，使⽤相同的函数名但具有不同的参数列表或类型，使得同⼀个函数名可以有<strong>多个版本</strong>。</p>
<pre><code>int add(int a, int b) &#123;
return a + b;
&#125;
double add(double a, double b) &#123;
return a + b;
&#125;
</code></pre>
<ul>
<li><p>操作符重载：</p>
<pre><code> #include &lt;iostream&gt;

 class MyNumber &#123;
    private:
    int value;

    public:
    MyNumber(int val) : value(val) &#123;&#125;

    MyNumber operator+(const MyNumber&amp; other) &#123;
          return MyNumber(value + other.value);
    &#125;

 int getValue() const &#123;
          return value;
    &#125;
 &#125;;

 int main() &#123;
    MyNumber num1(5);
    MyNumber num2(10);

    MyNumber sum = num1 + num2;

    std::cout &lt;&lt; &quot;The sum is: &quot; &lt;&lt; sum.getValue() &lt;&lt; std::endl;
    
    return 0;
  &#125;
</code></pre>
<p>  以下操作符<strong>不可以</strong>重载：</p>
<ul>
<li>成员选择操作符（.）：无法改变点操作符的行为。</li>
<li>展开操作符（::）：它用于指定作用域，不能被重载。</li>
<li>条件运算符（?:）：无法改变条件运算符的行为。</li>
<li>sizeof：它是一个关键字，无法重载。</li>
<li>typeid：它是一个运算符，无法重载。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>重写</strong>：重写是指派⽣类（⼦类）重新实现（覆盖）基类（⽗类）中的虚函数，以提供特定于派⽣类的实现。重写是⾯向对象编程中的多态性的⼀种体现，主要涉及基类和派⽣类之间的关系，⽤于实现运⾏时多态。</p>
<pre><code>class Base &#123;
public:
virtual void print() &#123;
cout &lt;&lt; &quot;Base class&quot; &lt;&lt; endl;
&#125;
&#125;;
class Derived : public Base &#123;
public:
void print() override &#123;
cout &lt;&lt; &quot;Derived class&quot; &lt;&lt; endl;
&#125;
&#125;;
</code></pre>
</li>
</ul>
<h3 id="18-虚函数和虚函数表"><a href="#18-虚函数和虚函数表" class="headerlink" title="18.虚函数和虚函数表"></a>18.虚函数和虚函数表</h3><ul>
<li>1.<strong>虚函数</strong>：C++中的虚函数的作⽤主要是实现了多态的机制。虚函数允许在派⽣类中重新新定义基类中定义的函数，使得通过基类指针或引⽤调⽤的函数在运⾏时根据实际对象类型来确定。这样的机制被称为动态绑定或运⾏时多态。在基类中，通过在函数声明前⾯加上 virtual 关键字，可以将其声明为虚函数。派⽣类可以重新定义虚函数，如果派⽣类不重新定义，<strong>则会使⽤基类中的实现</strong>。</li>
<li>2.<strong>虚函数表</strong>：虚函数的实现通常依赖于⼀个被称为虚函数表（虚表）的数据结构。<strong>每个类（包括抽象类）都有⼀个虚表</strong>，其中包含了该类的<strong>虚函数的地址</strong>。&#x3D;&#x3D;每个对象都包含⼀个指向其类的虚表的指针&#x3D;&#x3D;，这个指针被称为虚指针（vptr）。</li>
</ul>
<h3 id="19-虚函数和纯虚函数的区别"><a href="#19-虚函数和纯虚函数的区别" class="headerlink" title="19.虚函数和纯虚函数的区别"></a>19.虚函数和纯虚函数的区别</h3><p>  1.虚函数：</p>
<ul>
<li>1.有实现</li>
<li>2.可选择是否实现：如果不实现就直接使用基类的默认实现</li>
<li>3.允许实例化</li>
<li>4.调用靠对象类型决定</li>
<li>5.virtual关键字来声明，但最后不要包含&#x3D;0</li>
</ul>
<p>2.纯虚函数：</p>
<ul>
<li><p>1.没实现</p>
</li>
<li><p>2.强制覆盖：派⽣类必须提供纯虚函数的具体实现，否则它们也会成为抽象类。</p>
</li>
<li><p>3.禁止实例化</p>
</li>
<li><p>4.最后使用&#x3D;0来声明</p>
<pre><code>class AbstractBase &#123;
public:
// 纯虚函数，没有具体实现
virtual void pureVirtualFunction() = 0;
// 普通成员函数可以有具体实现
void commonFunction() &#123;
// 具体实现
&#125;
&#125;;
</code></pre>
</li>
</ul>
<h3 id="20-抽象类和纯虚函数的区别"><a href="#20-抽象类和纯虚函数的区别" class="headerlink" title="20.抽象类和纯虚函数的区别"></a>20.抽象类和纯虚函数的区别</h3><ul>
<li><p>1.抽象类：抽象类是不能被实例化的类，它存在的主要⽬的是为了提供⼀个接⼝，供派⽣类继承和实现。抽象类中<strong>可以包含普通的成员函数</strong>、数据成员和构造函数，但它必须包含 <strong>⾄少⼀个</strong> 纯虚函数。即在声明中使⽤ virtual 关键字并赋予函数⼀个 &#x3D; 0 的纯虚函数。</p>
<pre><code>class AbstractShape &#123;
public:
// 纯虚函数，提供接⼝
virtual void draw() = 0;
// 普通成员函数
void commonFunction() &#123;
// 具体实现
&#125;
&#125;;
</code></pre>
</li>
<li><p>2.纯虚函数是在抽象类中声明的虚函数，它没有具体的实现，只有函数的声明。通过在函数声明的末尾使⽤ &#x3D; 0 ，可以将虚函数声明为纯虚函数。派⽣类必须实现抽象类中的纯虚函数，否则它们也会成为抽象类。</p>
<pre><code>class AbstractShape &#123;
public:
// 纯虚函数
virtual void draw() const = 0;
&#125;;
</code></pre>
</li>
</ul>
<h3 id="21-为什么不能有虚构造函数"><a href="#21-为什么不能有虚构造函数" class="headerlink" title="21.为什么不能有虚构造函数"></a>21.为什么不能有虚构造函数</h3><p>构造函数不能是虚的，原因在于：</p>
<ul>
<li>1.对象的构造过程：构造函数的任务是初始化对象。在调用任何构造函数之前，对象的内存必须先被分配。<strong>虚函数工作依赖于对象的虚表（vtable），而在构造函数运行之前，虚表指针还未被设置</strong>，因此在对象构造过程中不能使用虚机制。</li>
<li>2.确定性：构造函数用于创建新对象。在 C++ 中，<strong>虚函数的调用依赖于对象的动态类型。然而，在构造阶段，对象的动态类型是正在被构造的类</strong>。因此，没有逻辑上的需求或可能性去有一个“虚构造函数”，因为我们总是知道应该调用哪个构造函数。</li>
<li>3.设计决策：如果构造函数可以是虚的，这将意味着通过基类的构造函数可以创建派生类的对象，这违背了对象创建的基本原则，即构造函数是明确地为创建特定类型的对象而设计。</li>
</ul>
<h3 id="22-深拷贝与浅拷贝"><a href="#22-深拷贝与浅拷贝" class="headerlink" title="22.深拷贝与浅拷贝"></a>22.深拷贝与浅拷贝</h3><ul>
<li>1.深拷贝：深拷⻉是对对象的<strong>完全独⽴复制</strong>，包括对象内部动态分配的资源。在深拷⻉中，不仅复制<strong>对象的值</strong>，还会复制对象<strong>所指向的堆上的数据</strong>。</li>
<li>2.浅拷贝：浅拷⻉<strong>仅复制对象的值</strong>，⽽不涉及对象内部动态分配的资源。在浅拷⻉中，新对象和原对象<strong>共享相同的资源</strong>，⽽不是复制⼀份新的资源。</li>
</ul>
<p><strong>例子来区分深拷贝与浅拷贝的使用情况</strong>：</p>
<ul>
<li><p>1.<strong>基本类不会改变</strong>：<br>因为，基本类型赋值时，赋的是数据（所以，不存在深拷贝和浅拷贝的问题）。<br>如：</p>
<pre><code>Var x = 100;
Var y = x; //此时x和y都是100;
</code></pre>
<p> 如果要改变y的值，x的值不会改变。</p>
</li>
<li><p>2.引用类型赋值用的就是浅拷贝（因为只复制了地址）</p>
</li>
</ul>
<h3 id="23-智能指针"><a href="#23-智能指针" class="headerlink" title="23.智能指针"></a>23.智能指针</h3><p>智能指针：用于管理动态内存的对象，目的是在避免内存泄漏和方便资源管理</p>
<ul>
<li><p>1.unique_ptr:独占智能指针<br>独占所有权的智能指针：同一个时间内只有一个unique_ptr可以拥有对象的所有权。当unique_ptr被销毁时，<font style= "color:red">它指向的对象也会被自动销毁。</font></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() &#123;
      std::unique_ptr&lt;int&gt; uniquePtr(new int(10));
      if (uniquePtr) &#123;
            std::cout &lt;&lt; *uniquePtr &lt;&lt; std::endl; // 输出10
      &#125;
      uniquePtr.reset(); // 手动释放内存
      return 0;
&#125;
</code></pre>
</li>
<li><p>2.shared_ptr:共享智能指针<br>是一种共享所有权的智能指针，多个shared_ptr可以<font style= "color:red">同时拥有同一个对象的所有权</font>。引用计数被用来追踪有多少个shared_ptr共享同一个资源，当没有shared_ptr指向对象时，对象将被自动销毁。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() &#123;
      std::shared_ptr&lt;int&gt; sharedPtr1 = std::make_shared&lt;int&gt;(10);
      std::shared_ptr&lt;int&gt; sharedPtr2 = sharedPtr1;

      std::cout &lt;&lt; *sharedPtr1 &lt;&lt; &quot; &quot; &lt;&lt; *sharedPtr2 &lt;&lt; std::endl; // 输出10 10

      sharedPtr1.reset(); // 释放sharedPtr1所指向的对象

      if (sharedPtr2) &#123;
            std::cout &lt;&lt; *sharedPtr2 &lt;&lt; std::endl; // 输出10
      &#125;

      return 0;
&#125;
</code></pre>
</li>
<li><p>3.weak_ptr:弱引用智能指针<br>是一种非拥有性的智能指针。它指向由某个<strong>shared_ptr管理</strong>的对象，但不会增加对象的引用计数。这允许weak_ptr访问资源而不阻止其被销毁。它主要用来解决shared_ptr的循环引用问题。需要通过std::weak_ptr的<strong>lock方法</strong>获取std::shared_ptr来访问对象。如果对象已经被释放，lock方法会返回一个空的std::shared_ptr。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() &#123;
      std::shared_ptr&lt;int&gt; sharedPtr = std::make_shared&lt;int&gt;(10);
      std::weak_ptr&lt;int&gt; weakPtr(sharedPtr);

      if (auto lockedPtr = weakPtr.lock()) &#123;
            std::cout &lt;&lt; *lockedPtr &lt;&lt; std::endl; // 输出10
      &#125;

      sharedPtr.reset(); // 释放sharedPtr，引用计数为0

      if (weakPtr.expired()) &#123;
            std::cout &lt;&lt; &quot;Weak pointer expired&quot; &lt;&lt; std::endl;
      &#125;

      return 0;
&#125;
</code></pre>
</li>
</ul>
<p><strong>问：既然都是看shared_ptr的数值，为啥我就不用其他指针看呢？</strong></p>
<ul>
<li>因为可以避免shared_ptr的循环引用。</li>
<li>同时可以安全地观察一个由std::shared_ptr管理的对象，而不会增加引用计数，这意味着它不会<strong>延长对象的生命周期</strong>。这在需要访问对象但不想影响其生命周期时非常有用。</li>
</ul>
<h3 id="23-STL"><a href="#23-STL" class="headerlink" title="23.STL"></a>23.STL</h3><p>C++ STL（Standard Template Library，标准模板库）是C++语言的一个非常核心的组成部分，它提供了一系列的模板类和模板函数。这些模板类和函数可以帮助程序员更高效地处理数据结构和算法操作，而无需从头开始编写所有代码。<br>包含以下4个组成部分：<br>1.容器</p>
<ul>
<li>序列容器：如vector，list，deque</li>
<li>关联容器：set，map，multiset，multimap</li>
<li>无需容器：如unordered_set, unordered_map, unordered_multiset,unordered_multimap</li>
<li>容器适配器（如stack, queue, priority_queue）<br>2.算法：例如sort，find<br>3.迭代器<br>4.函数对象</li>
</ul>
<h3 id="24-vector与list的区别："><a href="#24-vector与list的区别：" class="headerlink" title="24. vector与list的区别："></a>24. vector与list的区别：</h3><ul>
<li>1.vector底层实现是<strong>数组</strong>；list是<strong>双向链表</strong></li>
<li>2.vector是顺序内存,⽀持随机访问，list不⾏</li>
<li>3.vector在中间节点进⾏插⼊删除会导致内存拷⻉，list不会</li>
<li>4.vector⼀次性分配好内存，不够时才进⾏翻倍扩容；list每次插⼊新节点都会进⾏内存申请</li>
<li>5.vector随机访问性能好，插⼊删除性能差；list随机访问性能差，插⼊删除性能好</li>
</ul>
<h3 id="25-map-amp-amp-set的区别和实现原理"><a href="#25-map-amp-amp-set的区别和实现原理" class="headerlink" title="25.map&amp;&amp;set的区别和实现原理"></a>25.map&amp;&amp;set的区别和实现原理</h3><p>map内部实现了⼀个红⿊树<font style= "color:red">（红⿊树是⾮严格平衡的⼆叉搜索树，⽽AVL是严格平衡⼆叉搜索树）</font>，红⿊树有⾃动排序的功能，因此map内部所有元素都是有序的，红⿊树的每⼀个节点都代表着map的⼀个元素。因此，对于map进⾏的查找、删除、添加等⼀系列的操作都相当于是对红⿊树进⾏的操作。<br>map中的元素是按照⼆叉树（⼜名⼆叉查找树、⼆叉排序树）存储的，特点就是左⼦树上所有节点的键值都⼩于根节点的键值，右⼦树所有节点的键值都⼤于根节点的键值。使⽤中序遍历可将键值按照从⼩到⼤遍历出来。</p>
<p><em><strong>共同点：</strong></em><br>都是C++的关联容器,只是通过它提供的接⼝对⾥⾯的元素进⾏访问，底层都是采⽤红⿊树实现。<br><em><strong>不同点：</strong></em><br>set：⽤来判断某⼀个元素是不是在⼀个组⾥⾯。<br>map：映射，相当于字典，把⼀个值映射成另⼀个值，可以创建字典。<br><em><strong>优点：</strong></em><br>查找某一个数的时间为O(logn)；便利时候采用iterator<br><em><strong>缺点：</strong></em><br>每次插⼊值的时候，都需要调整红⿊树，效率有⼀定影响。</p>
<h3 id="26-map与unordered-map的区别"><a href="#26-map与unordered-map的区别" class="headerlink" title="26.map与unordered_map的区别"></a>26.map与unordered_map的区别</h3><p>map中元素是⼀些key-value对，关键字起索引作⽤，值表示和索引相关的数据。<br><em><strong>底层实现：</strong></em></p>
<ul>
<li>map底层是基于红⿊树实现的，因此map内部元素排列是<font style= "color:red">有序的</font>。 </li>
<li>unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱⽆序的。</li>
</ul>
<h4 id="红黑树的特点"><a href="#红黑树的特点" class="headerlink" title="红黑树的特点"></a>红黑树的特点</h4><ul>
<li>1.节点由红色和黑色组成</li>
<li>2.根节点是黑色</li>
<li>3.所有叶子节点都是黑色</li>
<li>4.红色节点的两个子节点一定是黑色的</li>
<li>5.从任一节点到其每个叶子节点的所有路径都包含相同数量的黑色节点，用于保证树的平衡</li>
<li>普通的二叉搜索树中，树有可能退化为链表，这样就会导致查找、插入、删除操作的时间复杂度变为 O(n)。而红黑树通过颜色的规则避免这种退化，保证树的高度不超过2*log(n)</li>
</ul>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul>
<li><strong>优点</strong><br>有序性，这是map结构最⼤的优点，其元素的有序性在很多应⽤中都会简化很多的操作。 map的查找、删除、增加等⼀系列操作时间复杂度稳定，都为O(logn)。</li>
<li><strong>缺点</strong><br>查找、删除、增加等操作平均时间复杂度较慢，与n相关。</li>
</ul>
<h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><ul>
<li><strong>优点</strong><br>查找、删除、添加的速度快，时间复杂度为常数级O(1）</li>
<li><strong>缺点</strong><br>因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占⽤率⾼。<br>unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(1)，取决于哈希函数。极端情况下可能为O(n)。</li>
</ul>
<h3 id="27-迭代器"><a href="#27-迭代器" class="headerlink" title="27.迭代器"></a>27.迭代器</h3><p>迭代器为不同类型的容器提供了统⼀的访问接⼝， 隐藏了底层容器的具体实现细节，允许开发者使⽤⼀致的语法来操作不同类型的容器。</p>
<ul>
<li><strong>序列容器</strong>vector，deque来说，使⽤erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动⼀位，erase返回下⼀个有效的迭代器。</li>
<li><strong>关联容器</strong>map，set来说，使⽤了erase后，当前元素的迭代器失效，但是其结构是红⿊树，删除当前元素，不会影响下⼀个元素的迭代器，所以在调⽤erase之前，记录下⼀个元素的迭代器即可。</li>
<li>list来说，它使⽤了不连续分配的内存，并且它的erase⽅法也会返回下⼀个有效的迭代器，因此上⾯两种⽅法都可以使⽤。</li>
</ul>
<h3 id="28-最抽象的一题：C-11的新特性有哪些"><a href="#28-最抽象的一题：C-11的新特性有哪些" class="headerlink" title="28.最抽象的一题：C++11的新特性有哪些"></a>28.最抽象的一题：C++11的新特性有哪些</h3><p>1.语法改进<br>（1）统⼀的初始化⽅法<br>（2）成员变量默认初始化<br>（3）&#x3D;&#x3D;auto关键字&#x3D;&#x3D;： 允许编译器⾃动推断变ᰁ的类型，减少类型声明的冗余。<br>（4）decltype 求表达式的类型<br>（5）&#x3D;&#x3D;智能指针&#x3D;&#x3D; std::shared_ptr 和 std::unique_ptr<br>（6）&#x3D;&#x3D;空指针 nullptr&#x3D;&#x3D;: 提供了明确表示空指针的关键字，替代了传统的 NULL 。<br>（7）基于范围的for循环: 简化遍历容器元素的语法<br>（8）&#x3D;&#x3D;右值引⽤和move语义&#x3D;&#x3D; 引⼊右值引⽤和移动构造函数，允许⾼效地将资源从⼀个对象移动到另⼀个对象，提⾼性能。<br>2.标准库扩充<br>（9）&#x3D;&#x3D;⽆序容器（哈希表）&#x3D;&#x3D; ⽤法和功能同map⼀模⼀样，区别在于哈希表的效率更⾼<br>（10）正则表达式 可以认为正则表达式实质上是⼀个字符串，该字符串描述了⼀种特定模式的字符串<br>（11）&#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;： 允许在代码中定义匿名函数</p>
<h3 id="29-为什么析构函数用虚函数好一点"><a href="#29-为什么析构函数用虚函数好一点" class="headerlink" title="29.为什么析构函数用虚函数好一点"></a>29.为什么析构函数用虚函数好一点</h3><p>当基类指针指向⼦类对象时，如果&#x3D;&#x3D;基类的析构函数不是 virtual&#x3D;&#x3D;，那么⼦类的析构函数将不会被调⽤，⼦类的资源没有正确是释放，因此造成内存泄露。这里指的是在构造函数中new定义了堆内存，而在析构函数中定义了释放。而子类析构函数的失效会导致new没有对应的delete。</p>
<h3 id="30-lambda表达式"><a href="#30-lambda表达式" class="headerlink" title="30.lambda表达式"></a>30.lambda表达式</h3><p><strong>lambda表达式基本语法</strong>：</p>
<pre><code>  [capture](parameters) -&gt; return_type &#123; body &#125;
</code></pre>
<ul>
<li>capture：捕获列表，指定哪些外部变量可以在Lambda表达式中使用。</li>
<li>parameters：参数列表，类似于函数的参数列表。</li>
<li>return_type：返回类型，可以省略，如果编译器能够推导出返回类型。</li>
<li>body：函数体，包含要执行的代码。<br>只有 [capture] &#x3D;&#x3D;捕获列表&#x3D;&#x3D;和 {body } &#x3D;&#x3D;函数体&#x3D;&#x3D;是必选的</li>
</ul>
<p><strong>捕获列表</strong>：</p>
<ul>
<li>[ ]：不捕获任何变量。</li>
<li>[&#x3D;]：按值捕获外部作用域中的所有变量。</li>
<li>[&amp;]：按引用捕获外部作用域中的所有变量。</li>
<li>[x]：按值捕获变量x。</li>
<li>[&amp;x]：按引用捕获变量x。</li>
<li>[&#x3D;, &amp;y]：按值捕获外部作用域中的所有变量，但按引用捕获变量y。</li>
<li>[&amp;, x]：按引用捕获外部作用域中的所有变量，但按值捕获变量x。</li>
</ul>
<p><strong>实例</strong>：<br><strong>按值捕获</strong>（[&#x3D;] 或 [x]）：按值捕获外部变量的当前值，Lambda表达式内无法修改这些变量。<br><strong>按引用捕获</strong>（[&amp;] 或 [&amp;x]）：按引用捕获外部变量，Lambda表达式内可以&#x3D;&#x3D;修改这些变量&#x3D;&#x3D;。<br><strong>隐式捕获</strong>（[&#x3D;] 或 [&amp;]）：捕获所有外部变量，[&#x3D;]按值捕获，[&amp;]按引用捕获。<br><strong>混合捕获</strong>：可以同时使用按值和按引用捕获特定的外部变量，如 [&#x3D;, &amp;x] 或 [&amp;, x]。</p>
<ul>
<li><p>1.基本lambda表达式：不捕获任何变量</p>
<pre><code>#include &lt;iostream&gt;

int main() &#123;
auto add = [](int a, int b) &#123;
      return a + b;
&#125;;

std::cout &lt;&lt; &quot;3 + 4 = &quot; &lt;&lt; add(3, 4) &lt;&lt; std::endl;
return 0;
&#125;
</code></pre>
</li>
<li><p>2.捕获外部变量：</p>
<pre><code>#include &lt;iostream&gt;

int main() &#123;
int x = 10;
int y = 20;

auto add = [x, y]() &#123;
      return x + y;
&#125;;

std::cout &lt;&lt; &quot;x + y = &quot; &lt;&lt; add() &lt;&lt; std::endl; // 输出: x + y = 30
return 0;
&#125;
</code></pre>
</li>
<li><p>3.按引用捕获变量</p>
<pre><code>      #include &lt;iostream&gt;

      int main() &#123;
      int x = 10;
      int y = 20;

      auto add_and_modify = [&amp;x, &amp;y]() &#123;
            x += 5;
            y += 5;
            return x + y;
      &#125;;

      std::cout &lt;&lt; &quot;x + y = &quot; &lt;&lt; add_and_modify() &lt;&lt; std::endl; // 输出: x + y = 35
      std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; std::endl;   // 输出: x = 15, y = 25
      return 0;
      &#125;
</code></pre>
</li>
</ul>
<h3 id="31-C语言与C-的区别"><a href="#31-C语言与C-的区别" class="headerlink" title="31.C语言与C++的区别"></a>31.C语言与C++的区别</h3><ul>
<li>1.面向对象编程<ul>
<li><strong>C语言</strong>：不支持面向对象编程，没有类、对象、继承、封装和多态等概念。</li>
<li><strong>C++语言</strong>：支持面向对象编程，引入了类、对象、继承、封装和多态等概念，使得代码复用性和可维护性大大提高。</li>
</ul>
</li>
<li>2.数据抽象和封装<ul>
<li><strong>C语言</strong>：主要通过结构体（struct）和函数来实现数据抽象。没有访问控制机制。</li>
<li><strong>C++语言</strong>：通过类和对象来实现数据抽象和封装。支持公有（public）、私有（private）和保护（protected）等访问控制机制。</li>
</ul>
</li>
</ul>
<h3 id="32-继承的内在实现"><a href="#32-继承的内在实现" class="headerlink" title="32.继承的内在实现"></a>32.继承的内在实现</h3><ul>
<li><p><strong>内存布局</strong><br>在继承的情况下，派生类对象的内存布局通常包括基类部分和派生类部分。&#x3D;&#x3D;基类部分在内存中的位置通常在派生类部分之前&#x3D;&#x3D;。一般内存布局如下：</p>
<pre><code>+------------------+
| base_data        |  // 来自 Base 类
+------------------+
| derived_data     |  // 来自 Derived 类
+------------------+
</code></pre>
</li>
<li><p>虚函数和虚函数表（vtable）<br>虚函数是C++中实现多态性的一种机制。当基类中有虚函数时，编译器会为类创建一个虚函数表（vtable）。虚函数表包含了类的虚函数指针。每个对象都有一个&#x3D;&#x3D;指向该表的指针&#x3D;&#x3D;，称为虚函数指针（vptr）。如果出现了B继承A，C继承B的情况发生。也是只有一个虚函数表存在，里面包含类ABC。</p>
</li>
</ul>
<h3 id="33-被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？"><a href="#33-被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？" class="headerlink" title="33.被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？"></a>33.被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？</h3><p>一种类中声明，一种通过子类中调用基类的函数</p>
<ul>
<li><p><strong>调用父类的同名函数</strong>：可以使用基类名加上作用域解析运算符来调用父类的同名函数。例如：</p>
<pre><code>class Base &#123;
public:
void function() &#123;
      cout &lt;&lt; &quot;This is the Base class function&quot; &lt;&lt; endl;
&#125;
&#125;;

class Derived : public Base &#123;
public:
void function() &#123;
      cout &lt;&lt; &quot;This is the Derived class function&quot; &lt;&lt; endl;
&#125;

void callBaseFunction() &#123;
      Base::function(); // 调用父类的同名函数
&#125;
&#125;;

Derived d;
d.function(); // 调用子类的同名函数
d.callBaseFunction(); // 调用父类的同名函数
</code></pre>
</li>
</ul>
<p>在上述示例中，Derived类中定义了一个与Base类同名的函数function。通过使用&#x3D;&#x3D;Base::function()&#x3D;&#x3D;，我们可以在子类中调用父类的同名函数。</p>
<ul>
<li><p>访问父类的同名成员变量：可以使用作用域解析运算符来访问父类的同名成员变量。例如：</p>
<pre><code>class Base &#123;
public:
int x;

void print() &#123;
      cout &lt;&lt; &quot;Base x: &quot; &lt;&lt; x &lt;&lt; endl;
&#125;
&#125;;

class Derived : public Base &#123;
public:
int x;

void print() &#123;
      cout &lt;&lt; &quot;Derived x: &quot; &lt;&lt; x &lt;&lt; endl; // 访问子类的同名成员变量
      cout &lt;&lt; &quot;Base x: &quot; &lt;&lt; Base::x &lt;&lt; endl; // 访问父类的同名成员变量
&#125;
&#125;;

Derived d;
d.x = 10;
d.Base::x = 20;
d.print();
</code></pre>
</li>
</ul>
<p>在上述示例中，Derived类和Base类都定义了一个同名的成员变量x。通过使用&#x3D;&#x3D;Base::x&#x3D;&#x3D;，我们可以在子类中访问父类的同名成员变量。</p>
<h3 id="34-拷贝构造函数"><a href="#34-拷贝构造函数" class="headerlink" title="34.拷贝构造函数"></a>34.拷贝构造函数</h3><p>拷贝构造函数的作用是<strong>创建一个对象的副本</strong>。<br>它在以下情况下被调用：</p>
<ul>
<li>1.对象的复制：当使用一个同类对象来初始化另一个同类对象时，拷贝构造函数被调用。例如，通过复制一个对象来创建一个新对象。</li>
<li>2.参数传递：当将对象作为参数传递给函数时，拷贝构造函数用于创建参数的副本。</li>
<li>3.返回值：当函数返回一个对象时，拷贝构造函数用于创建返回值的副本。</li>
</ul>
<p>需要自定义拷贝构造函数的情况：</p>
<ul>
<li>浅拷贝不够：如果类中有指针成员或资源（如文件句柄）需要进行深度拷贝，以防止多个对象共享同一资源。否则，当一个对象销毁时，共享的资源可能会被释放，从而导致其他对象的资源变为无效。</li>
<li>防止浅拷贝：如果类没有指针成员或资源，但是你希望禁止浅拷贝操作，以确保每个对象都有其自己的独立副本，而不是共享相同的数据。</li>
<li>高效率要求：有时候默认的拷贝构造函数可能不够高效，例如当类中有大量的数据或复杂的操作时。在这种情况下，自定义拷贝构造函数可以实现更高效的对象复制。</li>
</ul>
<p>例子：</p>
<pre><code>  #include &lt;iostream&gt;

  class MyClass &#123;
  public:
  int* data; // 指针成员

  // 默认构造函数
  MyClass() : data(nullptr) &#123;&#125;

  // 自定义拷贝构造函数
  MyClass(const MyClass&amp; other) &#123;
        // 执行深拷贝
        if (other.data != nullptr) &#123;
              data = new int(*other.data);
        &#125; else &#123;
              data = nullptr;
        &#125;
  &#125;

  // 析构函数
  ~MyClass() &#123;
        delete data; // 释放堆内存
  &#125;
  &#125;;

  int main() &#123;
  MyClass obj1;
  obj1.data = new int(10);

  MyClass obj2(obj1); // 使用拷贝构造函数进行深拷贝

  std::cout &lt;&lt; *obj1.data &lt;&lt; std::endl; // 输出: 10
  std::cout &lt;&lt; *obj2.data &lt;&lt; std::endl; // 输出: 10

  delete obj1.data;

  std::cout &lt;&lt; *obj2.data &lt;&lt; std::endl; // 输出: 10，仍然有效
  return 0;
  &#125;
</code></pre>
<p>上述代码中，MyClass类中包含了一个指针成员data。为了避免多个对象共享同一个内存资源，我们在拷贝构造函数中进行了深拷贝操作，即创建一个新的内存副本并将指针指向新的内存位置。这样，obj2对象将拥有独立的data指针和副本，而不会与obj1对象共享。至于析构函数中的delete操作，则用于释放堆内存，避免内存泄漏</p>
<p><em><strong>为什么这里用的是引用，这个引用有什么作用？</strong></em></p>
<ul>
<li><strong>避免无限递归</strong>：<br>因为如果不用&amp;，在调用这个构造函数时会调用ClassName(ClassName other);这行代码复制同样会调用拷贝构造函数，直接引用对象，就不会调用拷贝构造函数，避免无限递归</li>
<li>提高效率，避免不必要的拷贝：<br>引用传递对象而不是值传递，避免了对象的<strong>额外拷贝操作</strong>，从而提高了程序的效率。尤其是当对象包含大量数据或资源时（如动态分配的内存、文件句柄等），值传递会导致这些数据被多次复制，而引用传递则避免了这种开销。</li>
</ul>
<h3 id="35-静态绑定与动态绑定的介绍"><a href="#35-静态绑定与动态绑定的介绍" class="headerlink" title="35.静态绑定与动态绑定的介绍"></a>35.静态绑定与动态绑定的介绍</h3><ul>
<li>静态类型：对象在声明时使用的类型，在编译期就已经确定</li>
<li>动态类型：指针变量或引用变量所指向对象的类型，在运行期才能确定</li>
<li><strong>静态绑定</strong>：早期绑定，是在编译时确定函数调用的具体实现。在静态绑定中，编译器在编译时就能够决定应该调用哪个函数。这种绑定方式通常用于非虚函数和普通函数调用。</li>
<li><strong>动态绑定</strong>：动态绑定也称为晚期绑定（Late Binding），是在运行时确定函数调用的具体实现。动态绑定主要用于实现多态性，通常在类继承和虚函数的情况下使用。一般用在虚函数的实现。一般通过虚函数和指针或引用实现动态绑定。动态绑定可以根据对象的实际类型来调用对应的show函数。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>静态绑定发生在<strong>编译期</strong>，动态绑定发生在<strong>运行期</strong></li>
<li>对象的动态类型可以更改，但是静态类型无法更改</li>
</ul>
<p><strong>例子</strong>：这里的display函数就是动态绑定。</p>
<pre><code>  #include &lt;iostream&gt;

  class Base &#123;
  public:
  virtual void show() &#123;
        std::cout &lt;&lt; &quot;Base::show() called&quot; &lt;&lt; std::endl;
  &#125;
  &#125;;

  class Derived : public Base &#123;
  public:
        void show() override &#123;
              std::cout &lt;&lt; &quot;Derived::show() called&quot; &lt;&lt; std::endl;
        &#125;
        &#125;;

        void display(Base* base) &#123;
        base-&gt;show(); // 动态绑定，根据对象的实际类型调用对应的show函数
        &#125;

  int main() &#123;
        Base b;
        Derived d;
        display(&amp;b); // 调用Base::show()
        display(&amp;d); // 调用Derived::show()
        return 0;
  &#125;
</code></pre>
<h3 id="35-析构函数抛出异常会发生什么？"><a href="#35-析构函数抛出异常会发生什么？" class="headerlink" title="35.析构函数抛出异常会发生什么？"></a>35.析构函数抛出异常会发生什么？</h3><p>异常点之后的代码不会执行：当析构函数抛出异常时，异常将导致程序流程跳转到异常处理代码，导致异常点之后的代码不会被执行。这可能会导致对象销毁过程中的必要动作无法执行，例如释放资源，从而引发资源泄漏等问题。<br><strong>解决方法</strong>：</p>
<ul>
<li>使用智能指针，<strong>自动释放资源</strong>：使用C++中的智能指针（如std::unique_ptr、std::shared_ptr）来管理资源，可以自动处理资源的释放，避免手动管理资源导致的错误和异常。智能指针的析构函数会自动释放资源，即使在析构函数中抛出异常，也可以保证资源的正常释放。</li>
<li>分离资源管理，<strong>避免在析构函数中释放</strong>：将资源的释放操作从析构函数中分离出来，使用独立的函数或类来管理资源的释放。在析构函数中调用这些资源管理函数，如果资源释放过程中发生异常，可以通过合适的方式处理异常，避免资源泄漏。</li>
<li>做好异常处理，<strong>异常出现也可以正常处理</strong>：在析构函数中合理地使用异常处理机制，例如使用try-catch块捕获异常，并在catch块中适当地处理异常。这样可以保证即使在析构过程中发生异常，也不会导致程序崩溃或其他严重问题。</li>
</ul>
<h3 id="36-拷贝构造函数是什么？什么情况下会调用拷贝构造函数？"><a href="#36-拷贝构造函数是什么？什么情况下会调用拷贝构造函数？" class="headerlink" title="36.拷贝构造函数是什么？什么情况下会调用拷贝构造函数？"></a>36.拷贝构造函数是什么？什么情况下会调用拷贝构造函数？</h3><p>拷贝构造函数是<strong>类中特殊的构造函数</strong>，用于创建一个新的对象并将其初始化为同一类的另一个对象的副本。</p>
<ul>
<li><p>1.对象通过值传递或返回时：当对象作为函数参数按值传递或作为函数返回类型时，会触发拷贝构造函数的调用。这是因为在这些情况下，需要创建一个新的对象副本来传递给函数或作为返回值。</p>
</li>
<li><p>2.使用一个对象初始化另一个对象：当使用一个对象来初始化另一个对象时，会调用拷贝构造函数。这包括在创建一个新对象并用已存在的对象初始化它时，或者通过赋值运算符进行对象的初始化。</p>
</li>
</ul>
<h3 id="37-栈溢出一般是由哪些原因导致？"><a href="#37-栈溢出一般是由哪些原因导致？" class="headerlink" title="37.栈溢出一般是由哪些原因导致？"></a>37.栈溢出一般是由哪些原因导致？</h3><p>栈溢出是指程序在执行过程中，<strong>调用栈空间超过了栈的大小限制</strong>，导致向相邻的内存区域进行写操作，从而引发错误或崩溃。</p>
<p><strong>栈溢出</strong>一般由以下原因导致：</p>
<ul>
<li>递归调用没有终止条件或递归层数过深。</li>
<li>函数中声明的局部变量过多或过大。</li>
<li>递归数据结构中的递归层数过深。</li>
<li>使用了大量的函数调用，导致调用链过长。</li>
<li>异常处理中的递归调用过深。</li>
</ul>
<h3 id="38-静态成员函数与普通成员函数的区别？"><a href="#38-静态成员函数与普通成员函数的区别？" class="headerlink" title="38.静态成员函数与普通成员函数的区别？"></a>38.静态成员函数与普通成员函数的区别？</h3><ul>
<li><p>1.调用方式：</p>
<ul>
<li><p>静态成员函数可以直接通过&#x3D;&#x3D;类名来调用&#x3D;&#x3D;，无需创建类的对象。</p>
</li>
<li><p>普通成员函数必须通过类的对象或指针来调用。</p>
<pre><code>    class MyClass &#123;
    public:
          static void staticFunc() &#123;
                // 静态成员函数的实现
          &#125;

          void normalFunc() &#123;
                // 普通成员函数的实现
          &#125;
    &#125;;

    int main() &#123;
          // 调用静态成员函数
          MyClass::staticFunc();

          MyClass obj;
          // 调用普通成员函数
          obj.normalFunc();

          return 0;
    &#125;
</code></pre>
</li>
</ul>
</li>
<li><p>2.访问权限</p>
<ul>
<li>静态成员函数只能直接访问&#x3D;&#x3D;静态成员变量和静态成员函数&#x3D;&#x3D;，不能直接访问非静态成员变量和非静态成员函数。</li>
<li>普通成员函数可以直接访问类的所有成员，包括静态成员和非静态成员。</li>
</ul>
</li>
<li><p>3.存储方式</p>
<ul>
<li>静态成员函数不会影响类的对象的大小，它们存储在类的&#x3D;&#x3D;命名空间&#x3D;&#x3D;中，所有对象共享同一个静态成员函数。静态成员变量在程序的全局数据区（静态存储区）分配存储空间，静态成员函数存储在代码段。</li>
<li>普通成员函数被存储在类的对象中，每个对象都有自己的成员函数。非静态成员函数存储在代码段</li>
</ul>
</li>
<li><p>4.this指针</p>
<ul>
<li>普通成员函数有一个隐含的指向当前对象的指针，即 this 指针，可以在函数中使用 this 指针访问对象的成员。当你调用 a.func() 时，编译器实际上会使用对象 a 的 this 指针来访问该对象的成员，并从<strong>代码段</strong>中执行 func() 函数。</li>
<li>静态成员函数没有 this 指针，无法直接访问非静态成员。</li>
</ul>
</li>
</ul>
<h3 id="39-为什么静态成员函数不能访问非静态成员？"><a href="#39-为什么静态成员函数不能访问非静态成员？" class="headerlink" title="39.为什么静态成员函数不能访问非静态成员？"></a>39.为什么静态成员函数不能访问非静态成员？</h3><p>静态成员函数不能直接访问非静态成员变量和非静态成员函数，这是因为静态成员函数<strong>并不隶属于任何具体的对象</strong>，而是属于整个类。这导致在静态成员函数中没有隐含的指向对象的 &#x3D;&#x3D;this&#x3D;&#x3D; 指针。由于非静态成员是在对象的上下文中存在的，因此在没有对象的情况下，无法直接访问非静态成员。</p>
<h3 id="40-理解左值和右值？"><a href="#40-理解左值和右值？" class="headerlink" title="40.理解左值和右值？"></a>40.理解左值和右值？</h3><ul>
<li><strong>左值</strong>（L-value）：左值表示一个内存位置的标识符，可以出现在赋值语句的左边或右边。左值在表达式中是持久的，&#x3D;&#x3D;具有地址&#x3D;&#x3D;，并且可以被修改。可以将其简单理解为”可以取址的表达式”。一般来说，变量、函数或内存中的对象都可以是左值。</li>
<li><strong>右值</strong>（R-value）：右值表示&#x3D;&#x3D;暂时的、临时&#x3D;&#x3D;的值，不能出现在赋值语句的左边。右值在表达式中是短暂的，<strong>不具有地址</strong>，不能被修改。可以将其简单理解为”没有地址的表达式”。一般来说，常量、字面量、临时对象、表达式的结果等都可以被视为右值。</li>
</ul>
<h3 id="41-右值引用以及作用"><a href="#41-右值引用以及作用" class="headerlink" title="41.右值引用以及作用"></a>41.右值引用以及作用</h3><p>右值引用（rvalue reference）是C++11引入的一种引用类型，主要用于实现<strong>移动语义</strong>和<strong>完美转发</strong>。这有助于优化程序的性能，特别是在避免不必要的对象拷贝方面。右值引用使用双引号&amp;&amp;来表示。</p>
<p><strong>例子</strong>：拷贝构造函数+拷贝运算符</p>
<pre><code>  // 构造函数
  MyClass(size_t s) : size(s) &#123;
        data = new int[size];
        std::cout &lt;&lt; &quot;Constructor called for size &quot; &lt;&lt; size &lt;&lt; std::endl;
  &#125;

  // 拷贝构造函数
  MyClass(const MyClass&amp; other) : size(other.size) &#123;
        data = new int[size];
        std::copy(other.data, other.data + size, data);
        std::cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt; std::endl;
  &#125;

  // 移动构造函数，noexcept保证这个操作不会抛出异常
  MyClass(MyClass&amp;&amp; other) noexcept : data(nullptr), size(0) &#123;
        std::cout &lt;&lt; &quot;Move constructor called&quot; &lt;&lt; std::endl;
        *this = std::move(other);
  &#125;

// 拷贝赋值运算符
MyClass&amp; operator=(const MyClass&amp; other) &#123;
    if (this != &amp;other) &#123;
        delete[] data;
        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);
        std::cout &lt;&lt; &quot;Copy assignment operator called&quot; &lt;&lt; std::endl;
    &#125;
    return *this;
&#125;

// 移动赋值运算符
MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept &#123;
    if (this != &amp;other) &#123;
        delete[] data;
        data = other.data;
        size = other.size;
        other.data = nullptr;
        other.size = 0;
        std::cout &lt;&lt; &quot;Move assignment operator called&quot; &lt;&lt; std::endl;
    &#125;
    return *this;
&#125;
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>避免不必要的拷贝：通过<strong>移动</strong>而不是拷贝，可以显著提高程序的性能，特别是在处理大对象或资源密集型操作时。</li>
<li>实现高效的资源管理：右值引用和移动语义可以更高效地管理资源，如内存、文件句柄等。</li>
</ul>
<p><strong>移动语义</strong>：移动语义为了避免临时对象的拷贝，<strong>将内存的所有权从一个对象转移到另外一个对象</strong>，高效的移动用来替换效率低下的复制，为类增加移动构造函数。移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间同时将要拷贝的对象复制过来，而是”拿”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr。</p>
<p><strong>完美转发</strong>：它使得函数模板在接受参数时能够保持传递参数的原始值类别，无论是左值还是右值。 完美转发的原理是基于引用折叠（Reference collapsing）和函数重载解析。引用折叠是一种规则，用于在特定情况下将引用类型折叠为一个类型。在函数重载解析过程中，编译器会根据参数的值类别和函数模板的特化匹配最佳的函数。数模板使用模板参数来承载传递的参数，通过类型推导来确定参数的类型。<br>例子：</p>
<pre><code>  template &lt;typename T&gt;
  void process(T&amp;&amp; arg) &#123;
  otherFunction(std::forward&lt;T&gt;(arg));
  &#125;

  void otherFunction(int&amp; arg) &#123;
  std::cout &lt;&lt; &quot;L-value reference: &quot; &lt;&lt; arg &lt;&lt; std::endl;
  &#125;

  void otherFunction(int&amp;&amp; arg) &#123;
  std::cout &lt;&lt; &quot;R-value reference: &quot; &lt;&lt; arg &lt;&lt; std::endl;
  &#125;

  int main() &#123;
  int x = 10;

  process(x); // 传递左值，调用 L-value 引用版本
  process(5); // 传递右值，调用 R-value 引用版本

  return 0;
  &#125;
</code></pre>
<h3 id="42-函数模板与模板函数？"><a href="#42-函数模板与模板函数？" class="headerlink" title="42.函数模板与模板函数？"></a>42.函数模板与模板函数？</h3><ul>
<li><p><strong>函数模板</strong>：一种通用的函数模板声明，其中函数的参数和返回类型可以使用通用的模板参数来表示。函数模板的定义通常以 template<typename T> 或 template<class T> 开始，后跟函数的声明或定义。</p>
<pre><code>template&lt;typename T&gt;
T add(T a, T b) &#123;
return a + b;
&#125;

int intResult = add(5, 10);         // 实例化为 add&lt;int&gt;(5, 10)，返回 15
double doubleResult = add(3.14, 2.71);  // 实例化为 add&lt;double&gt;(3.14, 2.71)，返回 5.85
</code></pre>
</li>
</ul>
<p>在这个例子中，add 是一个函数模板，它可以接受相同类型的参数 a 和 b，并返回它们的和。模板参数 T 是一个占位符，表示函数中的类型。在函数调用时，编译器会根据实际的参数类型来实例化函数模板。</p>
<ul>
<li><p><strong>模板函数</strong>：对特定模板参数进行特化的函数定义。特化是指针对<strong>特定的模板参数类型编写的特殊版本</strong>。特化函数可以提供对特定数据类型的定制化行为。</p>
<pre><code>template&lt;typename T&gt;
T max(T a, T b) &#123;
return (a &gt; b) ? a : b;
&#125;

template&lt;&gt;
const char* max&lt;const char*&gt;(const char* a, const char* b) &#123;
return strcmp(a, b) &gt; 0 ? a : b;
&#125;
</code></pre>
</li>
</ul>
<p>在这个例子中，max 是一个函数模板，用于比较两个值并返回较大的值。然后，通过<strong>模板特化</strong> template&lt;&gt; 来定义 max 函数针对 const char* 类型的特殊版本。这个特殊版本使用了 strcmp 函数来比较两个 C 字符串并返回较大的字符串。</p>
<p><strong>也就是说</strong>：函数模版是一个通用的模版声明，可以适用于很多的数据类型，但是模版函数是对<strong>特定的模版特化的函数定义</strong>，开个小灶，对特定类型特定选择</p>
<h3 id="43-四种cast转换"><a href="#43-四种cast转换" class="headerlink" title="43.四种cast转换"></a>43.四种cast转换</h3><p>C++中有四种类型转换符可用于在不同类型之间进行类型转换。static_cast、dynamic_cast、const_cast和reinterpret_cast。</p>
<ul>
<li><p>static_cast：</p>
<ul>
<li><p>1.基本类型之间的转换，例如将int转换为double等</p>
</li>
<li><p>2.向上或向下进行继承关系的指针或引用转换。</p>
</li>
<li><p>注：<strong>向上转换（upcasting）</strong>：&#x3D;&#x3D;将派生类指针赋值给基类指针&#x3D;&#x3D;。这是安全的，&#x3D;&#x3D;因为派生类对象也包含基类对象部分&#x3D;&#x3D;。<strong>向下转换（downcasting）</strong>：将基类指针转换为派生类指针。这可能是不安全的，除非我们确信基类指针实际上指向一个派生类对象。</p>
<pre><code>    int num = 10;
    double convertedNum = static_cast&lt;double&gt;(num);
    class Base &#123;&#125;;
    class Derived : public Base &#123;&#125;;
    Base* basePtr = new Derived();
    Derived* derivedPtr = static_cast&lt;Derived*&gt;(basePtr);
</code></pre>
</li>
</ul>
</li>
<li><p>dynamic_cast:只适用于带有虚函数的多态类型</p>
<ul>
<li><p>1.向上转换：将派生类指针或引用转换为基类指针或引用。</p>
</li>
<li><p>2.安全地将基类指针转换为派生类指针（向下转换），在运行时进行类型检查，确保转换的安全性。</p>
<pre><code>    class Base &#123; virtual void foo() &#123;&#125; &#125;;
    class Derived : public Base &#123;&#125;;

    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);
    if (derivedPtr) &#123;
    // 转换成功
    &#125;
</code></pre>
</li>
</ul>
</li>
<li><p>const_cast：const_cast用于<strong>去除指针或引用的const属性</strong>。</p>
<pre><code>const int num = 10;
int* nonConstPtr = const_cast&lt;int*&gt;(&amp;num);
*nonConstPtr = 20; // 合法：修改nonConstPtr的值
</code></pre>
</li>
<li><p>reinterpret_cast：它可以将一个指针或引用转换为不同类型的指针或引用，甚至是完全无关的类型。除非绝对必要，否则应避免使用reinterpret_cast，并且使用前需要确保类型转换的合法性。<strong>什么都能转，就是不靠谱</strong></p>
<pre><code>int num = 10;
double* doublePtr = reinterpret_cast&lt;double*&gt;(&amp;num);  // 不安全，可能导致未定义行为

int* intPtr = reinterpret_cast&lt;int*&gt;(doublePtr);  // 转回原始类型
</code></pre>
</li>
</ul>
<h3 id="43-虚函数的工作机制"><a href="#43-虚函数的工作机制" class="headerlink" title="43.虚函数的工作机制"></a>43.虚函数的工作机制</h3><ul>
<li>1.在有虚函数的类中，当类实例化为对象时，会在对象的内存布局中添加一个指向虚函数表的指针。这个指针通常位于对象<strong>最开始的位置</strong>，也就是对象的 vptr（虚表指针）。</li>
<li>2.虚函数表是一个静态的表格，保存了类中所有虚函数的地址。这个虚函数表在内存中的位置通常是在代码段（.text）中，而不是在对象的<strong>实际内存</strong>中。</li>
<li>3.当子类继承了父类的时候，子类对象也会继承父类的虚函数表。当子类重写父类中的虚函数时，会将&#x3D;&#x3D;虚函数表中对应的函数地址替换为子类的虚函数地址&#x3D;&#x3D;，从而实现了动态绑定和多态。</li>
<li>4.运行时，通过对象的 vptr 指针来访问虚函数表，并根据表中存储的函数地址调用相应的虚函数。这个调用过程是动态的，会根据实际对象的类型来选择正确的虚函数实现。</li>
<li>5.虚函数的实现确实会增加访问内存的开销，因为需要通过 vptr 指针来访问虚函数表，并进行间接的函数调用。这可能会带来一些性能上的损失。对于不需要多态性的函数，可以选择将其声明为非虚函数，以提高性能。<br>所以虚函数永远都只存在虚函数表中，不管他是否已经声明了。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240709223421.png"></li>
<li>虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针。</li>
<li>每个类的派生类继承了基类的虚函数表，并可以在派生类中扩展和重写虚函数。派生类的虚函数表会包含基类的虚函数，并添加派生类自己的虚函数。派生类的虚函数表会替代基类的虚函数表。</li>
</ul>
<h3 id="44-虚函数和模版函数的区别？"><a href="#44-虚函数和模版函数的区别？" class="headerlink" title="44.虚函数和模版函数的区别？"></a>44.虚函数和模版函数的区别？</h3><ul>
<li><strong>虚函数</strong>：适用于需要运行时多态性的场景，通过基类指针或引用调用派生类的实现。运行时通过虚表来确定使用哪个函数</li>
<li><strong>模板函数</strong>：适用于需要编写泛型代码和实现编译时多态性的场景，可以在多个类型上复用相同的代码。编译时就已经确定好了</li>
</ul>
<h3 id="45-构造函数为什么一般不定义为虚函数？"><a href="#45-构造函数为什么一般不定义为虚函数？" class="headerlink" title="45.构造函数为什么一般不定义为虚函数？"></a>45.构造函数为什么一般不定义为虚函数？</h3><ul>
<li>虚函数的调用依赖于对象的类型，而在构造函数执行期间，&#x3D;&#x3D;对象的类型尚未完全确定&#x3D;&#x3D;。构造函数的目的是<strong>初始化对象</strong>，而不是多态性的实现。</li>
<li>在构造函数执行期间，对象的<strong>虚函数表（vtable）尚未被填充</strong>。因此，如果将构造函数声明为虚函数，虚函数调用将无法正确地解析到派生类的实现，因为派生类的虚函数表尚不存在。</li>
</ul>
<h3 id="46-构造函数或析构函数中调用虚函数会怎样"><a href="#46-构造函数或析构函数中调用虚函数会怎样" class="headerlink" title="46.构造函数或析构函数中调用虚函数会怎样"></a>46.构造函数或析构函数中调用虚函数会怎样</h3><ul>
<li>构造函数中虚函数的调用会使用<strong>当前类</strong>的实现，即使被派生类重写了该虚函数。</li>
<li>析构函数中虚函数的调用也会使用<strong>当前类</strong>的实现，即使该对象被派生类实例化。在析构函数期间，对象的动态类型已经丧失，只能使用当前类的实现，因为派生类的部分已经被销毁。</li>
</ul>
<h3 id="47-可以通过引用实现多态吗？"><a href="#47-可以通过引用实现多态吗？" class="headerlink" title="47.可以通过引用实现多态吗？"></a>47.可以通过引用实现多态吗？</h3><p>可以通过引用实现多态。多态是面向对象编程的一个重要概念，它允许使用基类类型的引用或指针来引用派生类对象，并根据实际对象的类型来调用相应的成员函数</p>
<pre><code>  #include &lt;iostream&gt;

  class Animal &#123;
  public:
        virtual void makeSound() const &#123;
              std::cout &lt;&lt; &quot;Animal makes a sound.&quot;;
  &#125;
  &#125;;

  class Dog : public Animal &#123;
  public:
        void makeSound() const override &#123;
              std::cout &lt;&lt; &quot;Dog barks.&quot;;
        &#125;
  &#125;;

  class Cat : public Animal &#123;
  public:
        void makeSound() const override &#123;
              std::cout &lt;&lt; &quot;Cat meows.
        &quot;;
  &#125;
  &#125;;

  int main() &#123;
        Dog dog;
        Cat cat;

        // 使用基类类型的引用，实现多态
        Animal&amp; animal1 = dog;
        Animal&amp; animal2 = cat;

        animal1.makeSound();  // 输出：Dog barks.
        animal2.makeSound();  // 输出：Cat meows.

        return 0;
  &#125;
</code></pre>
<p>通过使用基类指针或引用来引用子类对象，可以实现以下目标：</p>
<ul>
<li>实现多态性：允许通过基类指针或引用调用派生类的实现。</li>
<li>设计接口和抽象类：定义抽象接口，使得不同子类可以实现相同的接口。</li>
</ul>
<h3 id="48-vector-list-异同"><a href="#48-vector-list-异同" class="headerlink" title="48.vector list 异同"></a>48.vector list 异同</h3><p><strong>List</strong></p>
<ul>
<li>List是一个双向链表的容器，每个元素都由一个节点表示</li>
<li><strong>插入和删除元素</strong>的时间复杂度为O(1)</li>
<li>由于不具备随机访问特性，只能通过迭代器逐个遍历，时间复杂度为O(n)</li>
</ul>
<p><strong>vector</strong></p>
<ul>
<li>vector是一个动态数组的容器，元素的存储是<strong>连续的</strong>。</li>
<li>插入和删除元素的时间复杂度为O(n)，因为可能需要移动其他元素，尤其是在中间位置插入或删除元素时。</li>
<li>访问元素方面，由于具备随机访问特性，可以通过下标访问元素，时间复杂度为O(1)。</li>
<li>vector在增加元素时，如果超过自身最大的容量，vector则将自身的容量扩充为&#x3D;&#x3D;原来的两倍&#x3D;&#x3D;。扩充空间需要经过的步骤：<strong>重新配置空间，元素移动，释放旧的内存空间</strong>。一旦vector空间重新配置，则指向<strong>原来vector的所有迭代器都失效</strong>了，因为vector的地址改变了。</li>
</ul>
<h3 id="49-vector-deque的区别"><a href="#49-vector-deque的区别" class="headerlink" title="49.vector deque的区别"></a>49.vector deque的区别</h3><p>deque：双端队列</p>
<ul>
<li>双端操作：可以在头部和尾部进行高效的插入和删除操作。</li>
<li><strong>分段结构</strong>：内部实现采用分段的数据结构，只需要移动对应段内的元素，而不需要移动整个容器中的元素。</li>
<li><strong>支持随机访问</strong>：支持通过索引进行随机访问，可以在常量时间内访问任意位置的元素。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240714223324.png"></li>
</ul>
<p><strong>Deque和vector的区别</strong>：</p>
<ul>
<li><strong>插入和删除操作</strong>：Deque支持在头部和尾部高效地插入和删除元素，而Vector只能在尾部进行高效操作。</li>
<li><strong>内部实现</strong>：Deque采用&#x3D;&#x3D;分段&#x3D;&#x3D;的数据结构，而Vector是一块连续的存储空间。</li>
<li><strong>内存分配方式</strong>：Deque在扩容时能更高效地利用内存，并避免频繁的重分配，而Vector需要重新分配整块连续的内存空间。</li>
<li><strong>随机访问性能</strong>：Vector的随机访问性能更好，而Deque的随机访问相对较低。</li>
</ul>
<h3 id="49-迭代器删除元素"><a href="#49-迭代器删除元素" class="headerlink" title="49.迭代器删除元素"></a>49.迭代器删除元素</h3><ul>
<li><strong>1.vector&#x2F;deque容器</strong>：对于 std::vector 和 std::deque，当使用 erase 删除元素时，所有指向被删除元素之后的迭代器和引用都会失效。因此，在删除元素后，必须重新获取有效的迭代器。因为删除元素后vector容器会相亲啊移动元素来导致迭代器失效</li>
<li><strong>2.map和set容器</strong>：对于 std::set 和 std::map，删除元素时只有指向被删除元素的迭代器失效，其他迭代器仍然有效。因此，可以安全地删除元素而不影响其他迭代器。</li>
<li><strong>3.list容器</strong>：对于 std::list，删除元素时只有指向被删除元素的迭代器失效，其他迭代器仍然有效。这样就可以更加安全地删除元素而不需要担心其他迭代器的有效性。</li>
</ul>
<h3 id="50-几种模板插入的时间复杂度"><a href="#50-几种模板插入的时间复杂度" class="headerlink" title="50.几种模板插入的时间复杂度"></a>50.几种模板插入的时间复杂度</h3><p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240714224646.png"></p>
<h3 id="51-prioriry-queue优先级队列的底层数据结构是什么？操作的时间复杂度是什么？"><a href="#51-prioriry-queue优先级队列的底层数据结构是什么？操作的时间复杂度是什么？" class="headerlink" title="51.prioriry_queue优先级队列的底层数据结构是什么？操作的时间复杂度是什么？"></a>51.prioriry_queue优先级队列的底层数据结构是什么？操作的时间复杂度是什么？</h3><p>priority_queue（优先队列）在C++中可以使用堆（heap）作为其底层数据结构。堆是一种<strong>完全二叉树</strong>，具有以下性质：对于任意节点i，其父节点的值大于等于（或小于等于）其子节点的值。<br>因此操作复杂度为：</p>
<ul>
<li>插入操作（push）：O(log N)，其中N是优先队列中元素的数量。</li>
<li>删除顶部元素（pop）：O(log N)，其中N是优先队列中元素的数量。</li>
<li>查找顶部元素（top）：O(1)。</li>
</ul>
<h3 id="51-构造函数种类"><a href="#51-构造函数种类" class="headerlink" title="51.构造函数种类"></a>51.构造函数种类</h3><ul>
<li><p>1.默认构造函数<br>没有参数的构造函数直接生成默认构造函数</p>
<pre><code>class MyClass &#123;
public:
MyClass() &#123;
      // 默认构造函数
&#125;
&#125;;
MyClass obj;  // 调用默认构造函数
</code></pre>
</li>
<li><p>2.参数化构造函数<br>定义：包含一个或多个参数的构造函数。</p>
<pre><code>class MyClass &#123;
public:
MyClass(int x) &#123;
      // 参数化构造函数
&#125;
&#125;;
MyClass obj(10);  // 调用参数化构造函数
</code></pre>
</li>
<li><p>3.拷贝构造函数<br>用于创建一个对象的拷贝，参数是同一类型的对象的引用。</p>
<pre><code>class MyClass &#123;
public:
MyClass(const MyClass &amp;obj) &#123;
      // 拷贝构造函数
&#125;
&#125;;
MyClass obj1;
MyClass obj2 = obj1;  // 调用拷贝构造函数
</code></pre>
</li>
<li><p>4.移动构造函数<br>用于接收一个右值引用参数，并接管其资源。减少拷贝用到的资源。移动后boj1直接就被设置为nullptr了。</p>
<pre><code>class MyClass &#123;
public:
MyClass(MyClass &amp;&amp;obj) &#123;
      // 移动构造函数
&#125;
&#125;;
MyClass obj1;
MyClass obj2 = std::move(obj1);  // 调用移动构造函数
</code></pre>
</li>
<li><p>5.显式构造函数<br>使用 explicit 关键字修饰的构造函数。</p>
<pre><code>class MyClass &#123;
public:
explicit MyClass(int x) &#123;
      // 显式构造函数
&#125;
&#125;;
MyClass obj1(10);  // 正常
MyClass obj2 = 10;  // 错误，因为构造函数是显式的
</code></pre>
</li>
</ul>
<h3 id="52-unique-ptr底层实现"><a href="#52-unique-ptr底层实现" class="headerlink" title="52.unique_ptr底层实现"></a>52.unique_ptr底层实现</h3><p>unique_ptr 的最大特点是它只允许移动操作而不允许拷贝操作，这使得它非常适合管理动态分配的资源，而不会有多个指针共享同一资源的风险。<br>不允许拷贝主要是有class中声明了：</p>
<pre><code>  // 禁用拷贝构造函数和拷贝赋值运算符
  unique_ptr(const unique_ptr&amp;) = delete;
  unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
</code></pre>
<p>由于有析构函数所以可以直接邦正unique_ptr生命周期结束时，析构函数可以自动调用delete。</p>

            </div>

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2024/01/01/%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">驱动实现</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2024/01/01/%E5%85%AB%E8%82%A1%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">计算机网络问题</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2024
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">caijiQAQ</a>
            
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>










<div class="post-scripts">
    
        
<script src="/js/post-helper.js"></script>

        
        
    
</div>



</body>
</html>
