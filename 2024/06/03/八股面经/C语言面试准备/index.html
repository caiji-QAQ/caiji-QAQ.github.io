<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="caijiQAQ">
    
    <title>
        
            C语言面试准备 |
        
        学习笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"caiji-qaq.github.io","root":"/","language":"en"}
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"header_transparent":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":false,"preload":false},"code_copy":{},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":false,"min2read":false},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               学习笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">C语言面试准备</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">caijiQAQ</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2024-06-03 22:25:05</span>
        <span class="mobile">2024-06-03 22:25</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2024-08-14 16:14:11</span>
    </span>
    
    
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h3 id="1-int-main-int-argc-char-argv-函数中，参数argc和argv分别代表什么意思？"><a href="#1-int-main-int-argc-char-argv-函数中，参数argc和argv分别代表什么意思？" class="headerlink" title="1.int main(int argc, char ** argv)函数中，参数argc和argv分别代表什么意思？"></a>1.int main(int argc, char ** argv)函数中，参数argc和argv分别代表什么意思？</h3><p>在C语言中，主函数int main(int argc, char **argv)用来作为程序的入口，argc和argv是其参数。</p>
<ul>
<li>argc是整型参数，表示命令行参数的个数。它记录了程序在运行时附带的命令行参数的数量，至少为1，因为程序自身的名称也算一个参数。</li>
<li>argv是字符指针数组，用来存储命令行参数的字符串。每个元素指向一个以null结尾的字符串，表示一个命令行参数。<br>argv[0]指向程序的名称，argv[1]指向第一个参数，以此类推，argv[argc-1]指向最后一个参数。</li>
</ul>
<p>举个例子：</p>
<pre><code>./program arg1 arg2 arg3
</code></pre>
<p>那么argc的值就为4，同时argv的值为：<br>argv[0] &#x3D; “.&#x2F;program”<br>argv[1] &#x3D; “arg1”<br>argv[2] &#x3D; “arg2”<br>argv[3] &#x3D; “arg3”<br>argv[4] &#x3D; NULL</p>
<h3 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2.static关键字"></a>2.static关键字</h3><p>声明静态变量，使其<strong>生命周期延长</strong>或作用域限定在当前文件内。<br>声明静态函数，使其作用域限定在当前文件内。<br>（C++）声明静态成员变量，使其属于类本身而不是对象，<strong>多个对象共享同一份内存</strong>。<br>对于类举个例子，想用的时候不需要对象，直接使用类调用就行：</p>
<pre><code>#include &lt;iostream&gt;

class MyClass &#123;
public:
    static void staticFunction() &#123;
        std::cout &lt;&lt; &quot;This is a static function.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    MyClass::staticFunction(); // 输出: This is a static function.
    return 0;
&#125;
</code></pre>
<p>使用静态限定符，控制变量的初始化和生命周期。</p>
<h3 id="3-const和-define的区别"><a href="#3-const和-define的区别" class="headerlink" title="3.const和#define的区别"></a>3.const和#define的区别</h3><p>注：编译器运行的步骤：预处理、编译、汇编和链接</p>
<ul>
<li>const是一种编译器关键字，而#define是预处理器指令。const在<strong>编译</strong>阶段进行处理，而#define在<strong>预处理阶段</strong>进行处理。</li>
<li>const定义的<strong>常量具有类型</strong>，而#define没有。const在声明时需要指定常量的类型，编译器会进行类型检查。而#define只是简单的文本替换，没有类型检查。</li>
<li>const定义的常量有作用域限制，可以根据声明位置的不同而有不同的作用域。而#define定义的常量没有作用域限制，整个程序中都有效。</li>
<li>const生成符号表中的一个符号，有明确的名字和类型，可以进行调试和符号查找。而#define没有生成符号表，不会产生对应的符号。</li>
</ul>
<h3 id="4-extern"><a href="#4-extern" class="headerlink" title="4.extern"></a>4.extern</h3><ul>
<li><p>声明一个在其他文件中定义的外部变量或函数。</p>
</li>
<li><p>告诉编译器在链接过程中需要找到对应的定义。</p>
</li>
<li><p>允许在当前文件中使用这些外部变量或函数而不需要重新定义。<br><strong>使用：</strong></p>
<pre><code>  // File1.c
  extern int globalVar = 10;

  // File2.c
  #include &lt;stdio.h&gt;

  extern int globalVar;

  int main() &#123;
  printf(&quot;globalVar 的值：%d\n&quot;, globalVar);
  return 0;
  &#125;
  在 File1.c 中，我们使用 extern 关键字来定义一个全局变量 globalVar，并初始化为 10。
  在 File2.c 中，我们使用 extern 关键字来声明同名的全局变量 globalVar，以表示它是在其他源文件中定义的。
  然后，在 main 函数中，我们可以访问并打印 globalVar 的值。
</code></pre>
</li>
</ul>
<h3 id="5-include-lt-gt-和-include””的区别"><a href="#5-include-lt-gt-和-include””的区别" class="headerlink" title="5.#include&lt;&gt; 和 #include””的区别"></a>5.#include&lt;&gt; 和 #include””的区别</h3><p>使用 #include&lt;&gt;：</p>
<ul>
<li>用于包含系统提供的<strong>标准库头文件</strong>。</li>
<li>在编译器的<strong>搜索路径</strong>中寻找头文件。</li>
<li>编译器会先在系统的标准头文件目录中查找，如果找不到则报错。</li>
</ul>
<p>使用 #include””：</p>
<ul>
<li>用于包含<font style="color:red">用户自定义的头文件</font>或项目中使用的其他非系统头文件。</li>
<li>在当前源文件的相对路径或指定的绝对路径中寻找头文件。</li>
<li>编译器会首先在当前源文件所在目录中查找，如果找不到再根据指定的路径查找。</li>
</ul>
<h3 id="6-头文件-ifndef-x2F-define-x2F-endif的作用"><a href="#6-头文件-ifndef-x2F-define-x2F-endif的作用" class="headerlink" title="6.头文件#ifndef&#x2F;#define&#x2F;#endif的作用"></a>6.头文件#ifndef&#x2F;#define&#x2F;#endif的作用</h3><ul>
<li><p>#ifndef：<strong>用于判断当前头文件是否已经被包含。</strong></p>
</li>
<li><p>如果该宏之前没有被定义过，则继续编译下面的代码。</p>
</li>
<li><p>如果该宏之前已被定义过，则跳过下面的代码，直接到 #endif。</p>
</li>
<li><p>#define：用于定义一个宏。</p>
</li>
<li><p>通过定义一个特定的宏名称，例如MY_HEADER_H表示头文件已被包含。<br><font style="color:red">通过使用这种组合，可以防止同一个头文件被多次包含，以避免重复定义和编译错误。</font></p>
<pre><code>  #ifndef MYHEADER_H     // 如果 MYHEADER_H 还没有被定义
  #define MYHEADER_H     // 定义 MYHEADER_H

  void sayHello();       // 函数声明

  const int MAX_VALUE = 100;  // 常量定义

  #endif               // 结束条件编译
</code></pre>
</li>
</ul>
<h3 id="7-sizeof与strlen的区别"><a href="#7-sizeof与strlen的区别" class="headerlink" title="7.sizeof与strlen的区别"></a>7.sizeof与strlen的区别</h3><p>sizeof：</p>
<ul>
<li><p>用于获取<strong>数据类型或变量的字节大小</strong>。</p>
</li>
<li><p>可以接受多种参数，包括数据类型、变量名、数组名等。</p>
</li>
<li><p>返回的是整个数据类型或变量占用的内存空间大小。<br>strlen：</p>
</li>
<li><p>用于获取以’\0’结尾的<strong>字符串</strong>的实际长度。</p>
</li>
<li><p>在运行时计算，需要遍历字符串的内容来确定长度。</p>
</li>
<li><p>返回的是字符串中的字符个数，不包括字符串结束符’\0’。<br>举个例子：</p>
<pre><code>  char str[] = &quot;Hello&quot;;
  size_t size_str = sizeof(str);
  size_t length_str = strlen(str);
  // size_str 的值为 6，因为包括字符串 &quot;Hello&quot; 的 5 个字符和结尾的 &#39;\0&#39;，共 6 个字节
  // length_str 的值为 5，因为字符串 &quot;Hello&quot; 有 5 个字符，不包括结尾的 &#39;\0&#39;
</code></pre>
</li>
</ul>
<h3 id="8-int-a-int"><a href="#8-int-a-int" class="headerlink" title="8.int (*a)(int);"></a>8.int (*a)(int);</h3><p>是一个函数指针。它的含义是 a 是一个指向返回类型为 int 且接受一个 int 参数的函数的指针。<br>举例：</p>
<pre><code>#include &lt;iostream&gt;

// 定义一个函数，该函数接受一个 int 参数并返回 int
int myFunction(int x) &#123;
    return x * x;
&#125;

int main() &#123;
    // 定义一个函数指针，指向返回类型为 int，接受一个 int 参数的函数
    int (*a)(int);

    // 将函数指针指向 myFunction 函数
    a = &amp;myFunction;

    // 使用函数指针调用 myFunction 函数
    int result = a(5);

    // 输出结果
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; // 输出: Result: 25

    return 0;
&#125;
</code></pre>
<h3 id="9-结构体和共用体的区别"><a href="#9-结构体和共用体的区别" class="headerlink" title="9.结构体和共用体的区别"></a>9.结构体和共用体的区别</h3><h4 id="结构体：struct"><a href="#结构体：struct" class="headerlink" title="结构体：struct"></a>结构体：struct</h4><ul>
<li>内存布局：结构体中的每个成员都有自己的存储空间，所有成员的内存是&#x3D;&#x3D;顺序分配的&#x3D;&#x3D;。</li>
<li>内存大小：结构体的大小是所有<strong>成员大小之和</strong>，并且可能会由于&#x3D;&#x3D;内存对齐&#x3D;&#x3D;而稍微大一些。</li>
<li>访问方式：可以同时访问所有成员。</li>
<li>用途：用于需要同时存储多种不同类型的数据时。</li>
</ul>
<h4 id="共用体：union"><a href="#共用体：union" class="headerlink" title="共用体：union"></a>共用体：union</h4><ul>
<li>内存布局：共用体中的所有成员&#x3D;&#x3D;共享&#x3D;&#x3D;同一块内存。</li>
<li>内存大小：&#x3D;&#x3D;共用体的大小等于其最大成员的大小&#x3D;&#x3D;。</li>
<li>访问方式：同一时间只能访问一个成员，访问一个成员后，再访问另一个成员会导致前一个成员的数据被覆盖。</li>
<li>用途：用于需要在不同时间存储多种不同类型的数据时，节省内存空间。</li>
</ul>
<p>举个例子：</p>
<pre><code>    #include &lt;stdio.h&gt;
    struct MyStruct &#123;
    int x;
    float y;
    &#125;;
    union MyUnion &#123;
    int a;
    float b;
    &#125;;
    int main() &#123;
    struct MyStruct myStruct;
    union MyUnion myUnion;
    printf(&quot;结构体的大小: %zu 字节\n&quot;, sizeof(myStruct));
    printf(&quot;共用体的大小: %zu 字节\n&quot;, sizeof(myUnion));
    
    return 0;
    &#125;

    结构体的大小: 8 字节
    共用体的大小: 4 字节
</code></pre>
<h3 id="10-指针函数与函数指针的区别"><a href="#10-指针函数与函数指针的区别" class="headerlink" title="10.指针函数与函数指针的区别"></a>10.指针函数与函数指针的区别</h3><ul>
<li><p>指针函数：指针函数是<strong>一种返回指针类型的函数</strong>。指针函数的返回类型是一个指针，指向特定类型的数据。调用指针函数时，会返回一个指向函数计算结果的指针。</p>
<pre><code>  int* addIntegers(int a, int b) &#123;
  int* result = (int*)malloc(sizeof(int));
  *result = a + b;
  return result;
  &#125;
</code></pre>
</li>
<li><p>函数指针：函数指针是<strong>指向函数的指针变量</strong>。函数指针的类型声明中，指针符号 * 出现在函数名之前，用于表示函数指针的类型。函数指针可以用于直接调用指向的函数，或者作为参数传递给其他函数。其实就是这个函数类型的指针</p>
<pre><code>  #include &lt;stdio.h&gt;
  int addIntegers(int a, int b) &#123;
  return a + b;
  &#125;
  int main() &#123;
  int (*ptr)(int, int);  // 声明一个指向以两个整数为参数并返回整数的函数的指针变量
  ptr = addIntegers;  // 将函数地址赋值给函数指针
  int sum = ptr(5, 3);  // 通过函数指针调用函数
  printf(&quot;和: %d\n&quot;, sum);
  return 0;
  &#125;
</code></pre>
</li>
</ul>
<h3 id="11-原码、反码、补码的定义"><a href="#11-原码、反码、补码的定义" class="headerlink" title="11.原码、反码、补码的定义"></a>11.原码、反码、补码的定义</h3><p>原码：<strong>最高位表示符号</strong>，其余位表示数值的绝对值。正数的原码就是二进制表示，符号位为0。负数的原码符号位为1，数值位根据绝对值的二进制表示。<br>反码：正数的反码与原码相同，负数的反码是对原码除符号位外的每一位取反（0 变为 1，1 变为 0）。<br>补码：正数的补码与原码和反码相同，&#x3D;&#x3D;负数的补码是对反码加 1&#x3D;&#x3D;（取反加一）。</p>
<h3 id="11-内存分布模型"><a href="#11-内存分布模型" class="headerlink" title="11.内存分布模型"></a>11.内存分布模型</h3><p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240627232542.png"></p>
<ul>
<li><strong>代码段</strong>：存放程序的机器指令（即二进制代码）。通常是只读的，因为程序的指令在执行过程中不应该被修改。</li>
<li><strong>数据段</strong>：存放已初始化的全局变量和静态变量。这些变量在程序开始运行时已经赋予了初始值。</li>
<li><strong>BSS 段</strong>：存放未初始化的全局变量和静态变量。它们在程序开始运行时会自动初始化为0或者空指针。</li>
<li><strong>堆区</strong>：动态分配的内存空间，用于存放程序运行时动态申请的内存。（程序员可以通过函数（如malloc、calloc等）或者操作系统提供的接口来申请和释放堆内存，堆从低地址向高地址增长。）</li>
<li><strong>栈区</strong>：存放函数的局部变量、函数参数值以及函数调用和返回时的相关信息。栈区是按照“先进后出”的原则进行管理，内存的分配和释放是自动进行的，栈从高地址向低地址增长。是一块连续的空间。</li>
<li><strong>共享区</strong>：也称为文件映射或共享内存，用于实现不同进程之间的<strong>内存共享</strong>。</li>
</ul>
<h3 id="12-malloc和calloc的区别"><a href="#12-malloc和calloc的区别" class="headerlink" title="12.malloc和calloc的区别"></a>12.malloc和calloc的区别</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><ul>
<li>malloc 分配的内存是未初始化的，其中的字节内容是<strong>不确定的（可能是随机值）</strong>。</li>
<li>如果内存分配失败，malloc 返回一个空指针 NULL，可以通过检查返回值来判断是否分配成功。</li>
</ul>
<h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><ul>
<li>calloc 分配的内存&#x3D;&#x3D;会被初始化为全0&#x3D;&#x3D;。</li>
<li>calloc 在分配失败时会&#x3D;&#x3D;自动抛出错误（异常）&#x3D;&#x3D;，可以使用异常处理机制来捕获和处理错误。</li>
</ul>
<h3 id="13-malloc的底层原理"><a href="#13-malloc的底层原理" class="headerlink" title="13.malloc的底层原理"></a>13.malloc的底层原理</h3><ul>
<li>当<strong>开辟的空间小于 128K</strong> 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中&#x3D;&#x3D;堆段的末尾地址&#x3D;&#x3D;，不是数据段的末尾地址)</li>
<li>当<strong>开辟的空间大于 128K</strong> 时，mmap（）系统调用函数来在&#x3D;&#x3D;虚拟地址空间&#x3D;&#x3D;中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。</li>
</ul>
<h3 id="14-如果已知地址是0x3355，如何在这个地址上赋值为79"><a href="#14-如果已知地址是0x3355，如何在这个地址上赋值为79" class="headerlink" title="14.如果已知地址是0x3355，如何在这个地址上赋值为79"></a>14.如果已知地址是0x3355，如何在这个地址上赋值为79</h3><p>在 C 语言中，要在地址为 0x3355 的内存位置赋值为 79，可以使用指针来实现。以下是一个示例代码：</p>
<pre><code>unsigned char* p = (unsigned char*)0x3355;  // 将地址转换为无符号字符型指针类型
*p = 79;  // 赋值操作
</code></pre>
<p>这里一定要设置为无符号型指针(unsigned char*)，char类型只占用一个字节，如果使用int，int占用4个字节，这样的话，如果修改0x3355实际上会修改0x3355到0x3358的内容。</p>
<h3 id="15-指针和引用的区别和转换"><a href="#15-指针和引用的区别和转换" class="headerlink" title="15.指针和引用的区别和转换"></a>15.指针和引用的区别和转换</h3><ul>
<li><strong>指针</strong>（Pointer）：<br>定义：指针是一种变量，&#x3D;&#x3D;存储了一个地址&#x3D;&#x3D;，该地址指向内存中的另一个变量。<br>特点：可以修改指针的指向，使其指向其他变量或空地址。可以进行指针运算，如指针加法和减法。可以通过解引用（Dereference）操作符 * 来访问指针所指向的变量。</li>
<li><strong>引用</strong>（Reference）：<br>定义：引用是变量的别名，它&#x3D;&#x3D;引用了同一块内存空间&#x3D;&#x3D;。<br>特点：<strong>引用一旦绑定到一个变量</strong>，便无法更改其引用的目标。操作引用和操作原变量是等价的，对引用的修改会反映在原变量上。引用不能指向空地址。</li>
</ul>
<p><strong>举个例子</strong>：不可重新绑定</p>
<pre><code>int a = 10;
int b = 20;

int&amp; ref = a; // ref 是 a 的引用
ref = b;      // 这是将 b 的值赋给 a，不是将 ref 重新绑定到 b
ref = &amp;b; // 错误，不能将引用重新绑定到另一个变量
</code></pre>
<p><strong>指针转引用例子</strong>：</p>
<ul>
<li><p>指针转引用：引用存储的是别名，所以得引用*ptr，要不就是ptr地址的别名了</p>
<pre><code>  int num = 10;
  int* ptr = #     // 声明指针并指向变量
  int&amp; ref = *ptr; // 将指针转换为引用

  // 使用引用
  ref = 20;
  cout &lt;&lt; num; // 输出：20
</code></pre>
</li>
<li><p>引用转指针：因为引用没有独立的地址，所以这里ptr存的是num的地址</p>
<pre><code>  int num = 30;
  int&amp; ref = num;    // 声明引用
  int* ptr = &amp;ref;   // 将引用转换为指针

  // 使用指针
  *ptr = 40;
  cout &lt;&lt; num; // 输出：40
</code></pre>
</li>
</ul>
<h3 id="16-简述内存泄漏，如何检测和避免？"><a href="#16-简述内存泄漏，如何检测和避免？" class="headerlink" title="16.简述内存泄漏，如何检测和避免？"></a>16.简述内存泄漏，如何检测和避免？</h3><p>内存泄漏是指在程序运行过程中，&#x3D;&#x3D;分配的内存没有被及时释放&#x3D;&#x3D;，导致这部分内存无法再被程序使用。长时间运行或发生频繁的内存泄漏可能导致系统资源不足，性能下降或程序崩溃</p>
<ul>
<li><p><strong>常见的内存泄漏情况</strong>：</p>
<ul>
<li>1.new和malloc申请资源使用后，没有用delete和free释放；</li>
<li>2.子类继承父类时，父类析构函数不是虚函数。</li>
<li>3.比如文件句柄、socket、自定义资源类没有使用对应的资源释放函数。</li>
<li>4.shared_ptr共享指针成环，造成循环引用计数，资源得不到释放。</li>
</ul>
</li>
<li><p><strong>检测内存泄漏</strong>:<br><strong>使用内存分析工具</strong>：使用工具如Valgrind（Linux），Dr. Memory（Windows），Instruments（macOS）等来检测内存泄漏。这些工具可以检查程序运行时的内存分配和释放情况，并报告潜在的泄漏位置。</p>
</li>
<li><p><strong>避免内存泄漏</strong>：</p>
<ul>
<li><strong>使用智能指针</strong>：C++中的智能指针（如std::shared_ptr、std::unique_ptr）可以自动管理内存释放，避免手动释放内存的疏忽。</li>
<li>务必正确配对分配和释放：确保<strong>每次内存分配都有相应的释放</strong>，释放内存的操作必须与分配内存的操作对应（malloc和free 一定要malloc和free的次数一致否则就泄露）。</li>
<li>减少全局变量和长时间存活的对象：全局变量和长时间存活的对象可能导致无法释放的内存，尽量避免过多使用。</li>
</ul>
</li>
</ul>
<p>智能指针的例子：</p>
<pre><code>#include &lt;memory&gt;
#include &lt;iostream&gt;

int main() &#123;
    std::shared_ptr&lt;int&gt; sp1(new int(10)); // 使用裸指针创建 shared_ptr
    std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *sp1 &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl; // 引用计数
    return 0;
&#125;
</code></pre>
<h3 id="17-如果我想在函数中声明一个内存，同时想返回给主函数一个指针应该怎么做？"><a href="#17-如果我想在函数中声明一个内存，同时想返回给主函数一个指针应该怎么做？" class="headerlink" title="17.如果我想在函数中声明一个内存，同时想返回给主函数一个指针应该怎么做？"></a>17.如果我想在函数中声明一个内存，同时想返回给主函数一个指针应该怎么做？</h3><p>答：正常写就行，因为函数中new出来的内存函数不会销毁，如下：</p>
<pre><code>shared_ptr&lt;int[]&gt; allocateMemory(int size) &#123;
    std::shared_ptr&lt;int[]&gt; ptr(new int[size]);
    for (int i = 0; i &lt; size; ++i) &#123;
        ptr[i] = i * 10; // 初始化数组
    &#125;
    return ptr;
&#125;
</code></pre>
<h3 id="18-内存碎片"><a href="#18-内存碎片" class="headerlink" title="18.内存碎片"></a>18.内存碎片</h3><p>内存碎片是指在内存管理过程中产生的未被有效利用的零散、<strong>不连续的内存空间</strong>。主要分为两种类型：内部碎片和外部碎片。</p>
<ul>
<li><strong>内部碎片</strong>：是由于固定大小的内存分配方式或<strong>对齐</strong>要求等原因导致的未被利用的小空间。当分配给进程的内存块大于所需的大小时，其中的剩余空间就成为了内部碎片。</li>
<li><strong>外部碎片</strong>：是由于存在未分配的连续内存空间<strong>太小</strong>而不能满足分配请求，从而导致这些内存无法被有效利用。</li>
</ul>
<h3 id="19-什么是内存池"><a href="#19-什么是内存池" class="headerlink" title="19.什么是内存池"></a>19.什么是内存池</h3><p><strong>内存池</strong>（Memory Pool）是一种动态内存分配与管理技术。通常情况下习惯使用new&#x2F;delete&#x2F;malloc&#x2F;free等API申请分配和释放内存，这样导致的后果是：当程序长时间运行时，由于所申请的内存块大小不定，频繁使用时会造成<strong>大量的内存碎片</strong>从而降低程序和操作系统的性能。内存池则是在真正使用内存之前，<strong>先申请分配一大块内存(内存池)留作备用</strong>，当我们申请内存时，从池中取出一块动态分配的内存，释放内存时，再将我们使用的内存释放到我们申请的内存池内，再次申请内存池也可以再取出来使用。并且，<strong>尽量与周边的内存块合并</strong>。若内存池不够时，则自动扩大内存池，从操作系统中申请更大的内存池。</p>
<p><strong>内存池的好处</strong>：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20240630230235.png"><br>假设系统依次分配了16,16,4,8,8字节，接着释放了16字节和8字节归还给了系统（红色表示还未归还给系统），那么现在堆区空闲了一个16字节的空间和一个8字节的空间。这是如果用户要想申请出一个24字节的空间，那么系统就无法分配连续的空间给用户。这就是内存碎片的问题。</p>
<h3 id="20-初始化为0的全局变量在bss还是data"><a href="#20-初始化为0的全局变量在bss还是data" class="headerlink" title="20.初始化为0的全局变量在bss还是data"></a>20.初始化为0的全局变量在bss还是data</h3><p>初始化为0的全局变量通常会被分配到程序的BSS（Block Started by Symbol）段。BSS段是用于存放未初始化或初始化为0的全局变量和静态变量的一部分内存空间。在程序加载时，系统会自动将BSS段中的变量初始化为0。</p>
<p>已经明确初始化为非零值的全局变量会被分配到程序的数据（Data）段。Data段用于存放已经初始化的全局变量和静态变量。<br>总结来说，<strong>初始化为0的全局变量</strong>通常会被分配到<strong>BSS段</strong>，而已初始化为<strong>非零值的全局变量</strong>则会被分配到<strong>Data段</strong>。<br>BSS段包含未初始化的全局变量和静态变量，程序启动时这些变量会&#x3D;&#x3D;自动初始化为零&#x3D;&#x3D;。当程序加载时，操作系统可以简单地将BSS段清零，而<strong>不需要从磁盘读取数据</strong>，节省了可执行文件的空间。</p>
<h3 id="21-常见的预定义宏"><a href="#21-常见的预定义宏" class="headerlink" title="21.常见的预定义宏"></a>21.常见的预定义宏</h3><ul>
<li><p>1.__FILE__<br>展开为当前源文件的名称（字符串形式）。</p>
</li>
<li><p>2.__LINE__<br>展开为当前行号（整数形式）。</p>
</li>
<li><p>3.__DATE__<br>展开为编译时的日期（字符串形式），格式为 “MMM DD YYYY”，例如 “Aug 13 2024”。</p>
</li>
<li><p>4.__TIME__<br>展开为编译时的时间（字符串形式），格式为 “HH:MM:SS”。</p>
</li>
</ul>

            </div>

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2024/06/16/docker%E7%BC%96%E7%A8%8B/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">docker编程</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2024/05/05/linux%20camera%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">linux camera项目实现</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2024
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">caijiQAQ</a>
            
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>










<div class="post-scripts">
    
        
<script src="/js/post-helper.js"></script>

        
        
    
</div>



</body>
</html>
