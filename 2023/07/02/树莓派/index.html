<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="caijiQAQ">
    
    <title>
        
            树莓派 |
        
        学习笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"caiji-qaq.github.io","root":"/","language":"en"}
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"header_transparent":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":false,"preload":false},"code_copy":{},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":false,"min2read":false},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               学习笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">树莓派</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">caijiQAQ</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-07-02 15:55:47</span>
        <span class="mobile">2023-07-02 15:55</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2024-03-24 16:46:53</span>
    </span>
    
    
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <p>前期准备：<br>Datasheet：硬件手册，用于了解目标平台的规格&#x2F;寄存器&#x2F;内存地址&#x2F;引脚定义等<br>编译器：用于编译目标平台的驱动源码，嵌入式开发，一般用交叉编译器<br>内核源码：编译驱动依赖于内核，且必须与目标平台系统内核版本一致<br>外围电路原理图：连怎么走线都不知道，还开发个球啊！<br><a class="link"   target="_blank" rel="noopener" href="https://www.raspberrypi.com/documentation/computers/raspberry-pi.html" >引脚图<i class="fas fa-external-link-alt"></i></a><br><a class="link"   target="_blank" rel="noopener" href="https://datasheets.raspberrypi.com/rpi4/raspberry-pi-4-reduced-schematics.pdf?_gl=1*17haad8*_ga*Njk2NTc4NzMzLjE2ODgyODM2OTg.*_ga_22FD70LWDS*MTY4ODI4NTg2MC4yLjEuMTY4ODI4NTg4NC4wLjAuMA" >电路原理图<i class="fas fa-external-link-alt"></i></a>..<br>makefile介绍：<br>一个工程中的源文件不计数，按类型、功能、模块分别放在若干个目录中，Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，那些文件需要重新编译等，可以说Makefile关系到了整个工程的编译规则，因此会不会写Makefile，能不能写好Makefile，说明了一个程序员完成大型工程的能力。类似FPGA的testbench。<br>树莓派指令：<br>关机:sudo poweroff，直接断电会对板子有损害先关机再断电<br>预编译：make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- bcm2711_defconfig</p>
<h1 id="遇到的一堆问题"><a href="#遇到的一堆问题" class="headerlink" title="遇到的一堆问题"></a>遇到的一堆问题</h1><p><strong>1.vmware突然连不上网了</strong><br><strong>已解决</strong><br>出现该问题，第一步进行网络状态排查，通常也是最有效的方法之一。输入以下命令，查看网络状态信息。</p>
<pre><code>sudo vim /var/lib/NetworkManager/NetworkManager.state
</code></pre>
<p>看到网络状态信息 Networ：ikingEnabled&#x3D;false，<br>不知道怎么就被搞成了false，要想修改成true，需要以下步骤：</p>
<pre><code>关闭网络服务：sudo service network-manager stop
设置网络状态：sudo vim /var/lib/NetworkManager/NetworkManager.state，设置为true
打开网络服务：sudo service network-manager start
</code></pre>
<p>此时，就看到了网络连接成功的标识。</p>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230820145946.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230820150113.png"></p>
<p><strong>2.想要将版本同步的尝试：</strong><br>1.对下载后的树莓派提升版本，想要将自带的21版本升至最新版本，但是apt update之后还是21版本可能这只是对原有软件包更新了一下，而不是对整体进行更新。<br>2.准备完成官网的做法了，也没别的点子了，相同版本也难以同时找到img与源码，只能试着去生成，上一次生成时可能是文件系统格式出现问题，这次使用FAT32试一下。<br><strong>3.如何将磁盘分区</strong><br>在开始界面打入disk，找到磁盘界面分盘，开始需要点击-符号来将盘初始化为剩余空间，再点击+来创建分区，选择对应的文件写入形式（FAT32 EXT4）<br><strong>4.树莓派no wireless interface网络连接不上的问题</strong><br><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/lfri/p/11875527.html" >树莓派Wlan0:Not associated 报错解决方案<i class="fas fa-external-link-alt"></i></a><br>当执行 ifconfig wlan0 时，是有wlan0的网卡信息输出的。<br>当执行 ifconfig wlan0 up 是没问题的（即没有任何输出）。<br>执行 iwlist wlan0 scan | grep SSID 应该能看过周围环境的WIFI。<br>此时你只需要修改网络配置信息即可，<br>1.加一个网络凭条得到64位的PSK</p>
<pre><code>wpa_passphrase &quot;\&lt;ssid&gt;&quot; &quot;\&lt;password&gt;&quot; &gt;&gt; /etc/wpa_supplicant/wpa_supplicant.conf

network=&#123;
    ssid=&quot;ssid&quot;
    #psk=&quot;password&quot;
    psk=44116ea881531996d8a23af58b376d70f196057429c258f529577a26e727ec1b
&#125;
</code></pre>
<p>2.杀死进程然后再重新启动</p>
<pre><code>  killall wpa_supplicant 
  wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf 
</code></pre>
<p>就连接好了wifi<br><strong>5.Module in use</strong><br>由于测试驱动模块过程不小心输入了没有在应用层指定的字符，导致出现无法卸载模块：rmmod: remove ‘led_drv’: Resource temporarily unavailable，使用top命令（退出top使用ctrl+c）找到app对应的PID，执行kill -9 PID再卸载即可。下次注意不要使用应用程序向没有能力接受字符的驱动里输入字符了。一直卸载不掉关机也没办法重新insmod</p>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9E%B6%E6%9E%84.png"></p>
<p><strong>6.function declaration isnt a prototype</strong><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230715215640.png"></p>
<p>解决：将hello_init()改成了hello_init(void)奇迹般的解决了也是非常不理解了<br><strong>7.搞了半天发现找不到#include&lt;linux&#x2F;module.h&gt;</strong><br>解决：<br>通过修改environment文件:<br>vim &#x2F;etc&#x2F;environment中加入内核的路径最终找到</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>1.int main(int argc,char* argv[])详解</p>
<pre><code>int main(int argc,char* argv[]) 也可以写成 int main(int argc,char** argv)。
argc表示程序运行时发送给main函数的命令行参数的个数（包括可执行程序以及传参）。
argv[]是字符指针数组，它的每个元素都是字符指针，指向命令行中每个参数的第一个字符。

argv[0]指向可执行程序。
argv[1]指向可执行程序后的第一个字符串。
argv[2]指向可执行程序后的第二个字符串 。
argv[3]指向可执行程序后的第三个字符串 。
argv[argc]为NULL。
</code></pre>
<p>比如在Linu系统下使用vim编写以下代码，并保存为sample.c。</p>
<pre><code>#include &lt;stdio.h&gt;

int main(int argc,char** argv)
&#123;
int i;
printf(&quot;%d\n&quot;,argc);
for(i=0;i&lt;argc;i++)
&#123;
printf(&quot;%s\n&quot;,*argv);
argv++;
//printf(&quot;%s\n&quot;,argv[i]);
&#125;
&#125;
</code></pre>
<p>然后用“gcc sample.c -o sample.out”编译得到sample.out后，输入“.&#x2F;sample.out aa bb cc”执行。</p>
<pre><code>xjh@ubuntu:~/iot/tmp$ gcc sample.c -o sample.out
xjh@ubuntu:~/iot/tmp$ ls
sample.c  sample.out
xjh@ubuntu:~/iot/tmp$ ./sample.out aa bb cc
4      //显示有4个参数，显然把可执行程序也当做参数了
./sample.out           
aa
bb
cc
xjh@ubuntu:~/iot/tmp$ 
</code></pre>
<p>2.一堆宏<br>_<em>FILE</em><em>:表示当前源文件名，类型为字符串常量<br>_<em>LINE</em></em>:代表当前程序的行数<br>_<em>func</em><em>&#x2F;_<em>FUNCTION</em></em>:代表当前函数的函数名</p>
<h1 id="韦东山"><a href="#韦东山" class="headerlink" title="韦东山"></a>韦东山</h1><h2 id="01单片机与linux程序的分层"><a href="#01单片机与linux程序的分层" class="headerlink" title="01单片机与linux程序的分层"></a>01单片机与linux程序的分层</h2><p>单片机：有很多封装库，调库就可以解决大部分工程要求</p>
<h3 id="1-linux与单片机的区别"><a href="#1-linux与单片机的区别" class="headerlink" title="1.linux与单片机的区别"></a>1.linux与单片机的区别</h3><p>单片机和linux的主要不同是应用程序与驱动程序有无明显的界限</p>
<h3 id="2-linux下是无法同时读写寄存器的"><a href="#2-linux下是无法同时读写寄存器的" class="headerlink" title="2.linux下是无法同时读写寄存器的"></a>2.linux下是无法同时读写寄存器的</h3><p>为了保证安全，应用程序是无法直接访问到硬件的，访问硬件只能使用驱动程序，有严格分界；<br>甚至即使知道寄存器地址也无法读写：因为驱动程序与应用程序权限不一样。<br>MCU：微控制器单元，单片机<br>MPU：微处理器单元，跑linux的芯片含有mmu（内存管理单元）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230706202530.png"></p>
<center>图1 左MCU 右MPU</center>
左：MCU：可以传输地址也可以传输数据，没有权限管理。
右：MPU：但是多了一个MMU模块，MMU模块可以帮助权限管理，例如在APP模式下，用户想要访问GPIO MMU就会予以拒绝，但是当在内核模式下，MMU就会允许访问GPIO。
想要访问硬件就需要驱动程序

<h3 id="3-linux中应用程序如何调用驱动程序"><a href="#3-linux中应用程序如何调用驱动程序" class="headerlink" title="3.linux中应用程序如何调用驱动程序"></a>3.linux中应用程序如何调用驱动程序</h3><p>应用程序不能直接调用驱动程序的代码，也是安全问题。<br>swi #0 触发一个异常（类似中断）<br>CPU&#x3D;&gt;swi异常处理函数，由内核提供，同时也切换了到了内核模式，拥有更高的权限。<br>通过设置一个寄存器来判断是open还是read还是wirte。这样就能通过应用态切换到内核态了。根据R0分辩原因，调用不同的驱动程序。判断文件名普通文件就正常open、设备文件则通过驱动程序的open来读写寄存器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230706204951.png"></p>
<h2 id="02应用程序与驱动程序的接口"><a href="#02应用程序与驱动程序的接口" class="headerlink" title=" 02应用程序与驱动程序的接口"></a> 02应用程序与驱动程序的接口</h2><p>驱动&#x3D;框架+硬件操作（和MCU很像）<br>swi:software interrupt 软件异常<br>驱动相当于积木，只能是调用这个积木但是没办法修改形状<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230706210221.png"><br>第一节最后一张图的简略版（好看好多）</p>
<h2 id="03字符设备驱动程序框架"><a href="#03字符设备驱动程序框架" class="headerlink" title="03字符设备驱动程序框架"></a>03字符设备驱动程序框架</h2><h3 id="1-文件ls-l的属性"><a href="#1-文件ls-l的属性" class="headerlink" title="1.文件ls -l的属性"></a>1.文件ls -l的属性</h3><p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230706210918.png"><br>类别：c也就是属性是char 字符设备节点（如果是正常文件的话c的地方是-）<br>主设备号：属性节点下标识号</p>
<h3 id="2-写驱动程序"><a href="#2-写驱动程序" class="headerlink" title="2.写驱动程序"></a>2.写驱动程序</h3><h4 id="2-1应用程序如何找到驱动？"><a href="#2-1应用程序如何找到驱动？" class="headerlink" title="2.1应用程序如何找到驱动？"></a>2.1应用程序如何找到驱动？</h4><p>主要根据属性以及主设备号来找，暂时可以看做一个数组：chrdevs[主设备号]。</p>
<h4 id="2-2如何写一个驱动程序"><a href="#2-2如何写一个驱动程序" class="headerlink" title="2.2如何写一个驱动程序"></a>2.2如何写一个驱动程序</h4><p><strong>1 确定主设备号</strong>：选择一个名字没有占用的设备号，设置0则让系统自动分配了<br>(次设备号：比如有两个小灯，在一个主设备号下，判断点亮哪一个灯则需要次设备号，次设备号的含义是由自己决定的)<br><strong>2 构造一个结构体</strong>：file_operations里面是驱动的函数<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230706212019.png"><br>.owner是一个扩展语法，为了避免初始化时函数不用的输入都需要设置的情况，防止初始化过多。就比如ssize我不用的话正常就要写上NULL站上这个位置，但是使用.owner就不需要再在这个位置上写NULL了。<br><strong>3 注册</strong>：把结构体放在数组或者链表里<br>例如</p>
<pre><code>  major=register_chrdev(0,&quot;hello&quot;,&amp;hello_drv) ;
</code></pre>
<p>只要主设备号等于major的值就可以访问驱动程序了<br><strong>4 入口</strong>：入口函数用来调用注册函数，将2中结构体注册进了内核里（放到了数组里）module_init<br>而module_init只是一个宏定义，是更多代码的替代 因此可以将一个普通的c程序变成入口函数 ，一个驱动函数的入口函数是固定的：init_module<br>问题:如果入口函数一样编进内核那不就重名了？<br>编进内核就比再是原来的声明时候的意思了，编进内核第二个意思的结构体的值等于指针</p>
<p>整个流程就是：<br>应用程序open，中断，sysopen判断是字符设备节点，查找主设备号，调用数组里主设备号对应的驱动程序</p>
<h2 id="04字符设备驱动回顾与数据流程"><a href="#04字符设备驱动回顾与数据流程" class="headerlink" title="04字符设备驱动回顾与数据流程"></a>04字符设备驱动回顾与数据流程</h2><h4 id="1-节点分类"><a href="#1-节点分类" class="headerlink" title="1.节点分类"></a>1.节点分类</h4><p> 普通节点<br> char：字符节点<br> block：块节点 </p>
<h4 id="2-写一个驱动流程"><a href="#2-写一个驱动流程" class="headerlink" title="2.写一个驱动流程"></a>2.写一个驱动流程</h4><p>目的：open(“&#x2F;dev&#x2F;..”,”r&#x2F;w”)<br>1.a1,a2寄存器存入输入的参数（字符串这些）<br>2.R0&#x3D;val，R0存入是打开、读、写哪一种<br>3.swi#0 汇编指令发生异常，启动中断函数<br>4.内核判断R0的类型，判断操作的类型<br>5.判断文件的类型，是普通文件、字符设备节点、块设备节点哪一种。<br>6.通过文件（dev&#x2F;xxx）中声明的节点类型以及主次设备号来找到某个驱动。fileoperation<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230827113651.png"><br><strong>0 确定主设备号</strong><br><strong>1 构造结构体</strong><br>构造一个file_operation的结构体含有下面这三个函数<br>.open&#x3D;..<br>.read&#x3D;…<br>.wirte&#x3D;…<br><strong>2 注册</strong><br>将上面的结构体注册进一个数组里chardvs[n]<br>使用函数<br>major&#x3D;register_chrdev(主设备号,名字，&amp;fops)<br>注：如果主设备号设为0 ，major就会返回一个主设备号，&amp;fops:是结构体的地址<br><strong>3 入口</strong><br>入口函数用于调用注册函数，内核调用入口函数<br><strong>4 出口</strong><br>unregister_chrdev</p>
<h4 id="3-驱动程序如何调用-x2F-返回应用程序中输入的参数？"><a href="#3-驱动程序如何调用-x2F-返回应用程序中输入的参数？" class="headerlink" title="3.驱动程序如何调用&#x2F;返回应用程序中输入的参数？"></a>3.驱动程序如何调用&#x2F;返回应用程序中输入的参数？</h4><p>比如write想要写入参数，驱动程序是<strong>无法直接</strong>调用应用函数中的参数的，需要使用copy_to_user来传给user或是使用copy_from_user来得到函数中给的参数。</p>
<h4 id="4-驱动程序可以直接访问物理地址嘛？"><a href="#4-驱动程序可以直接访问物理地址嘛？" class="headerlink" title="4.驱动程序可以直接访问物理地址嘛？"></a>4.驱动程序可以直接访问物理地址嘛？</h4><p>也是不可以的，驱动程序中使用的是虚拟地址，而硬件使用的是物理地址，需要使用ioremap函数来将物理地址转换为虚拟地址，驱动程序通过虚拟地址才能访问到硬件的地址。得需要芯片手册才能得到物理地址。</p>
<h2 id="05入口出口"><a href="#05入口出口" class="headerlink" title="05入口出口"></a>05入口出口</h2><p>1.编译必须需要内核源码，因为使用函数必须要用到内核的头文件</p>
<ol>
<li><p>编写驱动程序</p>
<p> 1.入口函数以及出口函数名称都是确定的：init_module&#x2F;cleanup_module，但是也可以通过moudle_init来自己定义入口函数名<br> 2.printf要写成printk因为是printkernel。但是如果printk是无法直接显示在屏幕上看到的，应该如何查看呢，使用dmesg(开机显示函数)，printk使用之后会将数组传输给数组kerBuf下，这个数组可以传输给串口或者LCD，来令printk显示出来。<br> 3.卸载驱动以及装载驱动：sudo rmmod&#x2F;insmod hello_drv<br> 4.加入__init&#x2F;__exit这两个宏，加入段属性，来保证可以只使用一次将内存释放掉，因为init只在创建的时候有用，在内存的空间可以在使用过后释放掉。exit因为只在移除驱动程序的时候使用，不能释放所以这个有啥意义呢？<br>   exit是给那些编进内核的驱动程序使用的<br>   驱动可以被编进内核就不需要释放与出口，不能卸载一个编进内核的驱动程序，出口函数无存在必要exit保证不会链接进内核里，因为exit不会在内核里使用也就不会再内核里存放这个代码。<br> 5.MODULE_INIT指定的section是在flash还是在ram？<br>   linux内核一般都比单片机的会大好多，所以空间比较充裕，段也都在ram里。<br> 6.一个驱动模块有两种方式使用，一个是编进内核一个是insmod加载，这两者之间的区别。由于内核的空间很宝贵，所以一般只放一些必要的驱动程序，比如屏幕启动这些。而且如果将驱动编进内核如果内核的驱动出了bug也只能全部换掉，但是如果使用insmod加载则只需要替换掉有问题的加载驱动程序就可以了。</p>
</li>
</ol>
<p><strong>编译内核出现的问题</strong><br>写完.c和makefile之后发现warning：Module.symvers is missing<br><strong>问：Module.symvers是用来干什么的？</strong><br>在一个普通的C语言项目中，函数默认是一个强符号，在一个a.c中定义的函数，在b.c中声明之后就可以直接调用。而Linux内核则不支持这种调用方式：在a.c中定义的函数func，你要使用EXPORT_SYMBOL导出，然后在b.c中才能正常调用。如果你在a.c定义的func没有使用EXPORT_SYMBOL导出，b.c是无法调用的。a.c导出的符号func保存在各自目录下的Module.symvers文件中，内核编译时再将这些符号收集汇总，供其他模块调用。同样的道理，如果一个模块在编译时，需要导出符号供其他人使用，也会生成该模块对应的Module.symvers文件，保存在该模块的当前目录下。<br><strong>问：什么是交叉编译？</strong><br>C&#x2F;C++文件要经过 <strong>预处理（preprocessing）、编译（compliation）、汇编（assembly）和链接（linking）</strong> 等4步才能变成可执行文件，而可执行文件是给计算机执行用的<br><strong>预处理：</strong> C&#x2F;C++源文件中，以“#”开头的命令就是预处理命令，如包含命令“#include”、条件编译命令“#if”、“ifdef”、宏定义命令“#define”等。预处理就是将要包含（include）的文件插入源文件中、根据条件编译命令选择要使用的代码、将宏定义展开，最后将这些代码输出到一个“.i”文件，也就是说还是源代码文件。一般预处理都是些简单的替换、拷贝和选择。</p>
<p><strong>编译：</strong> 编译就是把C&#x2F;C++代码（比如上述的“.i”文件）翻译成汇编代码，生成“.s”文件，这部分设计复杂的编译原理。<br><strong>汇编</strong> 将汇编代码翻译成一定格式的机器代码，就是我们熟悉的目标文件（*.o），在Linux系统一般变现为ELF格式文件。<br><strong>链接</strong> 链接就是将汇编生成的OBJ文件、系统库的OBJ文件、库文件链接起来，也就是将各个ELF文件重新排序成一个ELF文件，最终生成可以在特定平台运行的可执行程序。（万剑归一，一个程序本省就可以写成一个文件）<br>交叉编译：举个例子，交叉编译就是一个美国人到中国来用中文考试，考试结果其它美国人看不懂，他自己也看不懂，但是中国人可以看懂的。不过他考试的方式是先用英文作答，然后用翻译软件翻译为中文。也就是在机器上可以编译出别的架构可以使用的程序（汇编）就是交叉编译。</p>
<h2 id="06-字符设备节点创建"><a href="#06-字符设备节点创建" class="headerlink" title="06 字符设备节点创建"></a>06 字符设备节点创建</h2><p><strong>1.块设备与字符设备</strong><br>块设备：系统中能够随机（不需要按顺序）访问固定大小数据片（chunks）的设备被称作块设备，这些数据片就称作块。最常见的块设备是硬盘<br>字符设备：字符设备按照字符流的方式被有序访问，像串口和键盘就都属于字符设备。<br>这两种类型的设备的根本区别在于它们是否可以被随机访问——换句话说就是，能否在访问设备时随意地从一个位置跳转到另一个位置。<br><strong>2.上层应用程序访问字符设备节点流程（加入.open,.read,.write)</strong><br><strong>1 定义一个结构体里面装有owner，read，write对应的函数，接着make得到.ko文件</strong></p>
<pre><code>static struct file_operations hello_fops=&#123;
.owner = THIS_MODULE,
/*  .read=hello_read,
.write=hello_write,*/
&#125;;
</code></pre>
<p><strong>2查找出驱动对应的主设备号</strong><br>cat &#x2F;proc&#x2F;devices<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230828202434.png"><br><strong>3 应用程序想要访问底层的驱动必须需要一个设备节点才能访问</strong><br>相当于是给主次设备号挂载一个地址来令应用程序可以通过该地址来访问这个设备<br>创建一个设备节点 mknod &#x2F;dev&#x2F;xyz c(chardev) 241（主设备号） 0（次设备号）<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230828203550.png"><br>文件属性也显示是一个字符设备<br><strong>4.最终通过应用程序调用显示</strong><br>hello_test.c gcc过后得到文件hello_test<br>sudo .&#x2F;hello_test -r:-r读数据<br>应用程序显示，对应的.c中的printf：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230828204526.png"><br>硬件显示：<br>dmesg |tail -5 也就是对应.ko中读文件的printk：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230828204739.png"></p>
<p>总结一下就是 insmod之后硬件提供的主设备号创建一个字符设备节点，应用程序再访问硬件对应的字符设备节点就可以实现驱动与应用层的数据传输。</p>
<h2 id="07-数据交互"><a href="#07-数据交互" class="headerlink" title="07 数据交互"></a>07 数据交互</h2><p><strong>1.应用程序r&#x2F;w内核的值</strong><br>read：<br>想要将底层的数据传输给应用程序，只能用copy_to_user，如果直接使用数组赋值，将会令系统崩溃<br>copy_to_user(应用的变量，&amp;内核空间的地址，拷贝的大小)<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230829201319.png"><br>write：<br>copy_from_user(&amp;内核空间的地址，应用的变量，拷贝的大小)</p>
<h2 id="08-地址空间"><a href="#08-地址空间" class="headerlink" title="08 地址空间"></a>08 地址空间</h2><p><strong>1.驱动程序与硬件交换</strong><br>ioremap通过物理地址返回得到的虚拟地址，驱动也就可以通过写虚拟地址来操作实际的物理地址上的内容。<br><strong>问：为什么使用虚拟地址？</strong><br>为了让linux可以支持一个任务同时运行多次，不得不引入虚拟地址。单片机上只能烧写一个程序，所以板子上程序的地址都是确定好的。而linux上会同时跑很多程序，地址也无法提前确定，因此无法确定一个明确的地址，这时就需要系统来分配一个虚拟地址，也就得到了一个映射。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230830202444.png"><br><strong>问：为什么需要用ioremap？</strong><br>只有通过虚拟地址才能访问得到物理地址，<br>问题1：当同样的程序运行，显示地址相同但是对应的值不同（如下图所示）</p>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230829204339.png"><br><strong>CPU与内存的交互</strong><br>CPU与内存：</p>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230829212147.png"><br>单片机中CPU在地址线传输地址给memory_controller，mc经过判断就会向想要的模块（RAM）发送信号令他启动，如果不发送信号的单元则不会传输信号。RAM则会通过数据线传回数据。</p>
<p>CPU与MMU（内存管理单元）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230829210629.png"><br>MMU的作用：<br>1.地址片选：用来区别输入的地址到底属于哪一个内存区域（比如ram，gpio，uart）<br>2.地址映射：将cpu输出的虚拟地址转化为物理地址，只有物理地址才能辨别是在哪个内存区域中。</p>
<p>只有通过物理地址才能访问到硬件，因此地址线上传输的是真实地址<br>运行同一个程序的时候，同一个虚拟地址可以对应多个物理地址<br>物理地址可以通过查找芯片手册得到，但是虚拟地址就要通过ioremap来得到。</p>
<h2 id="09驱动程序的辅助信息"><a href="#09驱动程序的辅助信息" class="headerlink" title="09驱动程序的辅助信息"></a>09驱动程序的辅助信息</h2><p>正常创建设备节点需要手动查找实在是太麻烦了，使用类就不需要手动mknod创建字符节点了。<br><strong>1.创建类</strong><br>class_create创建一个类(结构体)，会创建一个sys&#x2F;class&#x2F;hello_class，<br>device_create创建设备<br>class_create在&#x2F;sys&#x2F;devices&#x2F;virtual中创建了一个类里面有虚拟文件，其中的dev文件中就是设备信息。同时也成功让系统自动帮我们创建了一个字符设备节点。<br>这样就可以自动创建设备节点了，就不需要mknod了<br><strong>问：链接的作用</strong><br>是将工程中各个汇编文件内容连接在一起，比如全局变量，接着放到一个文件里，这个文件中的各个函数的位置都是确定好了的。</p>
<h2 id="10-点灯驱动程序"><a href="#10-点灯驱动程序" class="headerlink" title="10 点灯驱动程序"></a>10 点灯驱动程序</h2><p><strong>1.找到芯片手册以及想要操作的GPIO地址</strong><br>经查询树莓派4B+芯片为BCM2711，找到他的芯片手册以及对应的地址。<br><a class="link"   target="_blank" rel="noopener" href="https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf" >BCM2711芯片手册<i class="fas fa-external-link-alt"></i></a><br><strong>2.编写结构体以及内部对应的open，write函数</strong><br>注：应该在open函数调用再对GPIO初始化，原因：由于安装后也不一定什么时候会调用，提前初始化会占用资源，所以最好不要在__init函数中初始化而是在.open里单独声明。<br><strong>3.Makefile编写</strong><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230831204331.png"><br>对Makefile编写内容的解释：<br>进入$(KERN_DIR)这个内核目录，M&#x3D; pwd 在pwd这个路径下编译modules(模块)，obj-m代表了是led_drv.o这个模块<br><strong>注：</strong>交叉编译链不要随便用，因为每个芯片的指令集可能有所不同，比如arm9使用的是armv4的指令集，但是其他链使用的可能是armv8，也就是说编完之后是armv8的指令这样肯定是没法用的。<br><strong>4.将内核编写进内核</strong><br>内核目录下的drivers&#x2F;char&#x2F;Makefile文件中：<br>obj-m内核就不会编进内核映像文件中<br>obj-y就会编成为内核映像文件的一部分<br>问：$(CONFIG)这个变量在哪里被设置呢？<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230831205629.png"><br>内核根目录.config<br>问：.config如何生成的呢？<br>defconfig是一个默认配置文件，在(make)编译的时候会自动复制生成.config，同时.config也可以修改——make menuconfig，设置菜单下的这些目录都是从各个内核目录下的KConfig生成的。</p>
<p>cd 到&#x2F;drviers&#x2F;char字符设备路径下，将.c文件拷贝进来，接着修改内核目录(Makefile)，加入obj-$(CONFIG)+&#x3D;.o文件（$(CONFIG)就在.config里）<br>接着make，-m则使用make modules,-y则用make zImage -j将驱动编进内核里去。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230831210835.png"><br>查看创建的设备号：cat &#x2F;proc&#x2F;devices<br>查看地址号：cat &#x2F;proc&#x2F;iomem</p>
<h2 id="11-总线设备模型"><a href="#11-总线设备模型" class="headerlink" title="11 总线设备模型"></a>11 总线设备模型</h2><p><strong>分离：</strong> 分为固定的部分以及与设备相关会改变的部分<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231122201132.png"><br><strong>总线驱动模型：</strong> 将驱动放在一个总线（Bus）链表里共同管理<br>1）驱动程序要分为左右两边（驱动+device）这样会更容易扩展<br>2）构造drv，注册<br>3）构造dev，注册<br>4）匹配执行</p>
<p>linux自带platform_bus_type总线结构体<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231122201940.png"><br>调用总线match函数来匹配，若匹配则调用drv中probe函数<br><font style="background:yellow"><strong>整体流程</strong></font ><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231122202530.png"><br>但probe中所做的事情完全是由自己决定的，所以其他操作只是将drv、dev链接起来<br>匹配方法其实就是两者名字（.name）相同就可，如果名字相同就调用.probe<br>核心其实依旧是.probe里面的file_operation结构体，以上只是写法差异。<br><font style="background:yellow"><strong>注册设备与驱动链表的流程</strong></font ><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231122204234.png"></p>
<p>__***长成这个样子的函数都是代码的内部实现，要是要用的话就用前面定义的函数<br>dev需要定义一个resource数组来表示硬件资源，同时drv也要传入resource，这样也就做成了分离的效果。</p>
<p><strong>如何匹配</strong><br>在名字相同的情况下可以匹配，但是当想要多个dev匹配同一个drv时候会报错。<br>使用platform_bus_type的结构体中的.driver_override&#x3D;平台名字来实现匹配（相当于在同一组）<br>使用id_table定义支持哪些设备，定义leddrv可以支持什么设备名字。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231126160936.png"></p>
<h2 id="12-设备树"><a href="#12-设备树" class="headerlink" title="12 设备树"></a>12 设备树</h2><p><strong>原有问题：</strong> </p>
<ul>
<li>分离之后跑platformdev链表中具有大量的产品信息，比如一个产品多个版本就得有1.c 2.c 3.c，会让linux内核变得非常臃肿<br>现在我想直接把配置文件和内核分开，内核读取配置文件生成platformdev，这也就是设备树引入的原因和方法。</li>
</ul>
<p><strong>基础知识</strong></p>
<ul>
<li><p>.dtb文件是已经编译好的设备树文件，想知道源文件，可以查找对应的.dts文件，可以反编译：</p>
<p>  dtc -I dtb -O dts xxx.dtb &gt; 1.dts ^C</p>
</li>
</ul>
<p>-I:输入的格式dtb文件，-O：输出的格式 将xxx.dtb文件转换为1.dts</p>
<ul>
<li><p>设备树相当于替代了platformdev的功能，但是设备树文件转换为平台节点也需要一些要求，不满足要求的设备树文件是转换不成平台节点的。<br>要求1：要有compatible的属性<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231128202955.png"></p>
</li>
<li><p>尽管同为根节点的额子节点但会被注册成platformdev的只有下面的这个节点<br>设备树文件需要将dtb文件放到&#x2F;boot文件夹下，接着重启开发板<br>查看设备树文件要到&#x2F;sys&#x2F;firmware&#x2F;devicetree&#x2F;base（该目录相当于设备树的根目录）<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231128203704.png"><br>因此设备树的流程为：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231128203842.png"><br>某一些节点会转换为platformdev，转换为平台设备的要求就是需要有一个<font style="background:yellow">compatible属性</font>，平台总线设备就在这个目录下：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231128204236.png"></p>
</li>
<li><p>删除节点<br>比如现在我想要删除一个myled节点<br>1.我就可以使用&#x2F;delete-node&#x2F;来删除节点<br>2.我还可以加上一个状态,来告诉这个节点已经废了，什么也不需要去做</p>
<pre><code>  &amp;myled&#123;
      status=&quot;disabled&quot;;
      &#125;;
</code></pre>
</li>
</ul>
<p><strong>platformdriver与platformdev的匹配流程</strong></p>
<ul>
<li><p>实现platform_driver与dev的值相匹配，下面这个led_driver也有三种匹配的方法，使用.name名字比较，.of_match_table设备树比较，.id_table比较。</p>
<pre><code>  static struct platform_driver led_driver=&#123;
      .probe=eld_probe,
      .remove=led_remove,
      .driver=&#123;
          .name=&quot;100ask_led&quot;,
          .of_match_table=dts_devices_ids,
      &#125;,
      .id_table=led_id_table,
  &#125;;
</code></pre>
</li>
</ul>
<p>其中.of_match_table就是与设备树节点相匹配的表，而与设备树相匹配的要求就是compatible属性相匹配。dts_devices_ids的写法：</p>
<pre><code>    static const struct of_device_id dts_device_ids[]=&#123;
        &#123;.compatible=&quot;100askm,led&quot;,&#125;,
        &#123;/*sdentinel*/&#125;
    &#125;;
</code></pre>
<p>总而言之，设备树是一种可以描述硬件信息的形式。<br><strong>硬件的分类</strong></p>
<ol>
<li>GPIO</li>
</ol>
<ul>
<li>低电平有效</li>
<li>pin值</li>
<li>按键值（软件信息）：定义两个按键A&#x2F;B</li>
<li>描述灯GPIO设备的设备树应该怎么写：<br>设备树怎么写都是由驱动程序决定的，驱动程序如果需要一个子节点，那设备树就必须提供一个子节点。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231129202602.png"></li>
</ul>
<ol start="2">
<li>协议（I2C，SPI，UART）<br><font style="background:yellow">一个需要描述I2C控制器，另一个需要描述接入I2C的设备</font><br>描述I2C控制器：</li>
</ol>
<ul>
<li>pin</li>
<li>频率</li>
</ul>
<p>dtsi文件指的是include表示这个文件会被别的文件包含<br>下面这两个文件dtsi是厂家提供的代码，而dts是商家提供的代码，频率等参数也是由商家开发板所指定的。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231129205042.png"></p>
<p>而所接入的I2C设备：</p>
<ul>
<li>描述本身</li>
<li>在哪个I2C总线下</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231129205639.png"><br>在i2c1总线下创建一个子节点↑，这样也就表明了i2c总线和这个设备的关系<br>同名属性中含义有可能完全不同：就比如上面的两个reg，i2c1这个设备树里reg的含义就是制定了寄存器的地址以及后面0x4000都是这个设备。但at这个设备树里reg的含义就单纯的是这个地址。属性的含义由驱动来决定。</p>
<p>怎么修改设备树文件：<br>1.使用厂家工具<br>2.内核看绑定文档&#x2F;Documentation&#x2F;devicetree&#x2F;bindings<br>3.参考同类型设备树文件<br>4.网上搜索<br>5.实在没办法只能去研究驱动源码 </p>
<p><strong>pinctrl</strong><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231130201754.png"></p>
<ul>
<li>soc需要一个IOMUX模块来选择I2C等模块的引脚，IOMUX一般是包含在I2C等模块之中的，只是抽象出来为IOMUX。pin来选择接在那个模块上，例如由于I2C比较耗电，因此在休眠的时候pin也许就会接在GPIO上来进行一个省电的操作。<br>也就是I2C状态的选择与pinctrl息息相关：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231130202259.png"><br>pinctrl的使用，pinctrldevice的节点对应pinctrller的节点：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231130202619.png"></li>
<li><font style="background:yellow"><strong>驱动无需操作pinctrl</strong></font><br>原因：调用probe函数之前已经帮着设置好了引脚，因此driver里无需操作，只需要设备树里指定相关引脚，就会帮着设置，同时pinctrl每个厂家设置是有区别的<br>只有dev与drv比较匹配之后再.probe函数之前才会被调用，因此即使设备树文件中转换为平台设备了，也<font style="background:yellow">不会配置引脚</font><br>为什么USB不需要设备树?<br>对于复杂的接口<br>1.看原理图，根据引脚名字搜索设备树<br>2.确定pinctrl的名字<br>3.根据pinctrl的名字找节点：查看哪个dts里包含了这个名字，去查看</li>
</ul>
<h2 id="13-中断"><a href="#13-中断" class="headerlink" title="13 中断"></a>13 中断</h2><h3 id="13-1-应用程序和驱动程序交互的4种方式"><a href="#13-1-应用程序和驱动程序交互的4种方式" class="headerlink" title="13.1 应用程序和驱动程序交互的4种方式"></a>13.1 应用程序和驱动程序交互的4种方式</h3><p>妈妈怎么知道卧室里小孩醒了？<br>1.查询方式<br>时不时去房间看下<br>2.休眠唤醒<br>进去陪孩子一起睡，孩子醒了吵醒他，但是这种妈妈也干不了活了<br>3.poll方式<br>妈妈陪孩子小睡一会，定一个闹钟，要么孩子吵醒妈妈，要么闹钟吵醒妈妈干活<br>4.异步通知<br>妈妈在客厅干活，小孩醒了会自己走出房门告诉妈妈，异步通知≈中断，APP注册一个信号处理函数，底层有情况主动发送信号<br>前三种方式都是同步，只有最后一种方式是异步</p>
<h3 id="13-2-中断"><a href="#13-2-中断" class="headerlink" title="13.2 中断"></a>13.2 中断</h3><p>1.设置中断控制器<br>2.注册中断处理函数<br>3.保存现场：把当前的进程保存下来<br>4.调用处理函数<br>5.恢复现场</p>
<p>中断与异常之间的区别：<br>中断可屏蔽，异常不可屏蔽</p>
<p>阻塞方式：没有数据就休眠</p>
<h3 id="13-3-怎么写驱动"><a href="#13-3-怎么写驱动" class="headerlink" title="13.3 怎么写驱动"></a>13.3 怎么写驱动</h3><p>request_irq 中断处理函数</p>
<pre><code>request_irq(usigned int irq,irq_handler_t handler,unsigned long flags,const char *name,void *dev)
</code></pre>
<p>如何知道是哪一个irq呢？<br>查看设备树，为某一个设备指定中断。</p>
<ul>
<li><strong>中断结构：</strong><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231203112045.png"><br>看设备树的节点是否为中断控制器，如果是中断控制器设备树下就会有interrupt-controller：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231203112304.png"><br>GPIO1（2级中断控制器，用到了1级中断控制器的哪些中断：interrupts里有显示）<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231203112747.png"><br>层级关系可以从interrupt-parent里面看出来，说明他的父亲是intc这个设备树节点<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231203113334.png"><br>整体结构：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231203114248.png"></li>
<li><strong>中断的类型：</strong><br>1.软件触发中断(SGI，Software Generated Interrupt)<br>由软件通过写入专用仲裁单元的寄存器生成<br>2.私有外设中断(PPI，Private Peripheral Interrupt)<br>单个CPU核私有的外设生成<br>3.共享外设中断(SPI，Shared Peripheral Interrupt)<br>由外设生成的中断。</li>
</ul>

            </div>

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023/07/05/markdown%E8%AF%AD%E6%B3%95/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">markdown语法</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/06/23/%E7%BB%8F%E6%B5%8E/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">经济学习</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2024
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">caijiQAQ</a>
            
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>










<div class="post-scripts">
    
        
<script src="/js/post-helper.js"></script>

        
        
    
</div>



</body>
</html>
