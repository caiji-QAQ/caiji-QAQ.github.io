<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="caijiQAQ">
    
    <title>
        
            计算机系统 |
        
        学习笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"caiji-qaq.github.io","root":"/","language":"en"}
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"header_transparent":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":false,"preload":false},"code_copy":{},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":false,"min2read":false},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               学习笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">计算机系统</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">caijiQAQ</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-06-03 20:24:59</span>
        <span class="mobile">2023-06-03 20:24</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2024-08-10 21:58:07</span>
    </span>
    
    
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <p>##程序的机器级表示<br>or S,D D&lt;——D|S<br>sub S,D D&lt;——D-S<br>%rax用于存放函数返回值<br>###移位操作<br>SAL、SHL：左移指令<br>SAR：算术移位 填上符号位<br>SHR：逻辑移位 填上0<br>###x86-64命名<br>延续字 2字节<br>双字 4字节<br>四字 8字节<br>八字 16字节<br>对应传送指令 字节<br>movb 传送字节 1<br>movw 传送字 2<br>movl 传送双字 4<br>movq 传送四字 8<br>指令与字节：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230705224241.png"><br>###跳转<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/IMG_20230706_223245.jpg"><br>反汇编版本中是根据第二个字节的数值加上下一个指令的地址来判断跳转的地址，若出现f*这种情况则是负数(补码)，同样是与下一个指令的地址加和。<br>条件判断转移中第一种比较普通的方式：转移</p>
<pre><code>if（a&gt;b) goto state1
else goto state2
</code></pre>
<p>但这种情况一般情况下并不会使用，因为效率太低，计算机使用的是流水线的形式的提升效率，即可能在判断if的过程中已经开始编译下一步了，如果if判断为错就会让之前的编译白费。所以计算机一般是使用</p>
<pre><code>a1=a-b
a2 =b-a
c=a1&gt;a2
if c a1=a2
</code></pre>
<p>这种形式来提升效率</p>
<p>栈的地址与正常地址不同，是从底部开始向上递增。push进栈而pop从栈中读取数据。<br>call ret也用了同样的思想<br>程序计数器</p>
<p>开始的6个寄存器，如果参数的数量在6个以内则直接存放在下面的寄存器里，如果超出6个则会存在栈里，现在都是寄存器访问应用，因为寄存器速度要比栈中快很多<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230808222154.png"></p>
<p>stackframe：对于每一个还没返回的函数会保留一个栈帧，一般栈帧由两个指针相隔，一个是栈指针%rsp，一个是基指针（%rbp）。大多数系统限制了栈的深度。<br>即使其他程序也使用了%rbp和%rsp，也一定会保证将值返还<br>每一个函数都有自身各自的堆栈地址，保证不会存在空间互相占用的情况。</p>
<p><strong>机器语言中没有数组的概念，那么数组是如何表示的</strong><br>地址+偏移值（基本类型大小）<br>ip+x，如果x是负数，也有效，并且也会比ip要小，当声明一个数组大小时，确确实实分配了已知大小的内存<br>多维数组地址排列情况<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230819163754.png"><br>在创建结构的布局时，C编译器通常会加入填充字节让数据对齐。<br>数据对齐的好处：能让数据读取的更快（因为正常计算机一次会读取固定的量比如64bit，而且有的机器没有数据对齐会让内存出现问题。<br>下图也是由于要求双精度，令整个数据结构必须要在8字节边界上对齐：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230819170352.png"><br>对齐的优化也可以提升空间利用率，但编译器并不会主动去这么做来优化：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230819170643.png"></p>
<p>64位2机器限制只有47位的地址，所以可以支持的空间大小是：256*10^12字节，也就是256TB<br><strong>linux内存地址分布</strong><br>自地址低至地址高分别是：text data heap sharedlibraries stack<br>text：用于存放可执行程序的区域<br>data：用于存放程序开始时的数据，包括全局变量等<br>heap：用于存放通过malloc或相关的函数申请的变量，若一直申请但不释放地址也就会越来越大。在实际情况下，较大的变量会被分配在接近stack的一端，而较小的变量会分配在低地址这一端<br>stack：栈空间，该空间只有8MB，栈的分配从高到低，如果分配了一个调用8MB的指针就会出现问题不允许调用<br>总结：stack一般声明的是局部变量，而heap（malloc）一般是一小块或是一大块的变量<br><strong>缓冲区溢出</strong><br>输入目标大于缓冲区的大小。<br>在设置字符大小时注意给空字符留一位<br>为了避免缓冲区溢出可以使用更安全的写法：例如使用fgets来替换gets<br>fgets与gets的区别：fgets在输入字节超过规定的数字之后输入的字符串就会被截断，来保证不会缓冲区溢出。<br><strong>系统保护避免被攻击</strong><br>栈随机化（ASLR）：<br>地址空间布局随机化，这样就无法直接得到下一个地址，也就无法访问到系统代码，用于抵御蠕虫攻击。<br>将栈标记为不可执行：<br>这样不能把代码放在栈里。<br>canary（金丝雀）：<br>在地址上面的空间设置几个随机数，当溢出时canary的值就会被改变，可以检测到这个字节被修改。</p>
<p><strong>联合体</strong><br>在不同机器下，会得到不同的结果<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230820194414.png"><br><strong>union和struct的区别</strong><br>struct和union同样声明了<br>xxx S3{<br>    char C;<br>    int i[2];<br>    double v;<br>}<br>struct所占用的空间是1+4+8&#x3D;13byte<br>union所占用的空间是他最大字段的大小因此是8byte<br>union引用的是数据结构的起始位置。<br><strong>数据对齐</strong><br>对齐要求保证结构体内数据类型起始地址是自身字节数倍数<br>1.struct P1{int i;char c;int j;char d;};<br>偏移量0 4 8 12 对齐要求 4<br>2，struct P2{short w[3];char c[3]}<br>偏移量0 6 对齐要求 </p>
<h2 id="05-程序优化"><a href="#05-程序优化" class="headerlink" title="05 程序优化"></a>05 程序优化</h2><p>1.优化编译器的能力<br>命令行选项选择-Og&#x2F;-O2&#x2F;-O3可以让编译器以不同等级优化。<br>2.微处理器结构以及程序指令<br>现代微处理器结构：<br>处理器具有超标量：可以在每个时钟周期执行多个操作，并且为乱序的，指令执行顺序不一定要与他们机器级程序中的顺序一致。整体设计有两个主要部分：指令控制单元和执行单元。<br>指令控制单元：从内存中读出指令系列并根据序列生成一组针对程序数据的基本操作。<br>执行单元：执行操作。<br>乱序处理器与按序流水线对比<br>乱序处理器需要更大、更复杂的硬件，但可以更好地达到更高的指令级并行度。</p>
<p>遇到分支的情况：<br>处理器采用一种<strong>分支预测</strong>的技术，处理器会猜测是否是否选择分支，同时也会预测分支的目标地址。使用投机执行的技术，拿出预测分支进行译码，当错误时会重新回到分支点的状态，开始取出和执行另一个方向上的指令。</p>
<p>收到实际的程序指令：<br>会将一个指令转换为一组基本操作，以好被并行执行</p>
<p>退役单元：<br>用于记录正在进行的操作，一条操作指令完成了，所有引起指令的分支点也都会被认为预测正确，则指令就退役了，后面的操作也会正常执行，如果分支预测错误，这条指令就会被清空，丢弃所有计算出的结果，用于防止预测错误改变程序的状态。</p>
<p>3.功能单元性能<br>三个指标<br>延迟：完成运算所需要的总时间<br>发射时间：两个连续的同类型的运算之间所需要的最小时钟周期数<br>容量：能够执行该运算的功能单元的数量。<br>延迟也就是一个操作的总量（几块），发射时间就是可以流水线的单位时间。比如整数乘法操作 延迟为3，发射时间为1，总量为3，每次输入到处理器1个块。</p>
<p>流水线、完全流水线化（发射时间为1）</p>
<p>针对一个硬件的性能：功能单元的最大吞吐量，定义为发射时间的倒数。对一个容量为C发射时间为I的操作来说，处理器可能的吞吐量为每个时钟周期C&#x2F;I个操作。<br>CPE每个元素的周期数。<br>延迟界限：完成合并原酸的函数所需要的最小CPE值（总量）<br>吞吐量界限：CPE最小界限（处理器能做的最好是多少）</p>
<h1 id="06-存储器层次结构"><a href="#06-存储器层次结构" class="headerlink" title="06 存储器层次结构"></a>06 存储器层次结构</h1><p><strong>存储器系统：</strong> 一个具有不同容量成本和访问时间的存储设备的层次结构。主要分为：高速缓存(cache memory)，主存储器（main memory），磁盘。<br><strong>局部性：</strong> 具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是临近的数据项。良好局部性的程序较好可以从存储器层次结构较高的层次访问数据项，运行时间可以更短。</p>
<h2 id="1-存储技术"><a href="#1-存储技术" class="headerlink" title="1.存储技术"></a>1.存储技术</h2><p>###1.1随机访问存储器(RAM)<br><strong>1 静态与动态RAM</strong><br>静态RAM(SRAM)：更快但空间更小，可以在CPU芯片上也可以在片下，不易受到干扰。<br>动态RAM(DRAM)：慢但空间较大，作为驻村和图形系统的缓冲区，更易受到干扰。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230831224239.png"><br><strong>2 DRAM与超单元</strong><br>DRAM芯片中单元分为d个超单元，每个超单元由w个DRAM单元组成（w位数，d个数）<br>DRAN组成二维阵列而不是线性数组的原因：降低芯片上地址引脚的数量：16个超单元，芯片正常需要4个地址引脚，而做成二维需要两个；但二维阵列组织缺点是必须分成两部发送地址，增加访问时间。<br><strong>3 内存模块取出地址</strong><br>内存地址传输：64位的一个字，示例使用8个64Mbit的8M*8的DRAM芯片。存储：8个芯片，每个芯片取出一个超单元(i,j)存储主存的一个字节，也就是8个单元表示主存的64位字。取出：A转化为超单元的(i,j)内存模块将i,j广播到每个DRAM，每个DRAM分别传出对应位置的8bit组成64bit传回给内存管理器<br><strong>4 ROM</strong><br>ROM是一种非易失性存储器，即关电也会保存原有的信息（RAM无法维持信息）<br>ROM类型：<br>PROM：只能被编写一次<br>EPROM：可擦写可编程ROM，可以编程1000次<br>flash memory闪存：大量使用</p>
<p>固件：存储在ROM设备中的程序，计算机关键程序</p>
<p><strong>5 访问主存</strong><br>总线结构：主要分为IO桥链接CPU的系统总线和IO桥连接主存的内存总线。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230903110038.png"><br>从主存上读取数据：<br>1 CPU传输地址给系统总线，IO桥将信号给内存总线<br>2 内存总线将数据传输给内存总线，IO桥将内存总线信号翻译为系统总线信号，传输信号给系统总线<br>3 从系统总线上读取数据，并将数据复制给寄存器<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230903110600.png"></p>
<h3 id="1-2磁盘存储"><a href="#1-2磁盘存储" class="headerlink" title="1.2磁盘存储"></a>1.2磁盘存储</h3><p><strong>1.磁盘构造</strong><br>整体：盘片，每个盘片有两个盘面<br>磁盘表面：一组同心圆称为磁道，每个磁道被划分为一组扇区，扇区之间由间隙隔开<br>柱面：多个盘片驱动器的构造。例如：驱动器有6个盘面，每个表面磁道编号一致，那么柱面k是6个磁道k的集合。<br><strong>2.磁盘操作</strong><br>磁盘以扇区大小的块来读写数据，访问时间主要有三个影响因素：寻道时间，旋转时间，传送时间。分别对对应了三个步骤：读写头定位磁道，磁道上定位扇区，读取扇区信息。<br>寻道时间：读写&#x2F;头定位到想要读取数据磁道的时间<br>旋转时间：取决于磁盘旋转速度RPM<br>传送时间：读取一个扇区的时间，旋转速度+一个磁道上的扇区数量需要考虑到间隔的影响<br><strong>3.磁盘控制器</strong><br>对操作系统隐藏复杂性，磁盘显示为B个扇区大小的逻辑块序列，编号为0、1…、B-1。磁盘封装一个硬件&#x2F;固件设备—— <strong>磁盘控制器</strong> ，维持逻辑块号和实际磁盘分区的映射关系。磁盘控制器令操作系统读取信息变得更为简单。<br>当操作系统读取一个磁盘分区数据到主存：操作系统令磁盘控制器，读一个逻辑块号——控制器将逻辑块号翻译成一个（盘面，磁道，扇区）三元组。<br><strong>4.CPU读取磁盘信息</strong><br>IO总线：将例如图形卡、监视器、鼠标、键盘和磁盘这样的输入&#x2F;输出IO设备与CPU与主存相连。主机总线适配器可以将一个或多个磁盘连接到IO总线<br>注：主存：一般指RAM</p>
<p>读取过程总共分为3个步骤：<br>1.CPU发起命令读<br>2.磁盘控制读扇区，但CPU不再参与，因为磁盘读的过程很久（ms），CPU周期ns，这么长时间也不能让CPU干等着吧，于是就有了直接内存访问DMA，可以自己执行读或者写总线实物而不需要CPU干涉。<br>3.磁盘信息安全存储在驻村后，磁盘控制器发送一个中断信息通知CPU<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230903151230.png"></p>
<h3 id="1-3固态硬盘"><a href="#1-3固态硬盘" class="headerlink" title="1.3固态硬盘"></a>1.3固态硬盘</h3><p>固态硬盘是基于闪存的存储技术<br>优点：速度快，能耗更低，更结实<br>缺点：反复写会有磨损</p>
<h2 id="2-局部性"><a href="#2-局部性" class="headerlink" title="2.局部性"></a>2.局部性</h2><p>时间局部性：被引用过一次的内存位置很可能在不远的将来再被多次引用。反复利用<br>空间局部性：如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。引用的位置距离下一次引用的位置距离相近。</p>
<h2 id="3-存储器的层次结构"><a href="#3-存储器的层次结构" class="headerlink" title="3.存储器的层次结构"></a>3.存储器的层次结构</h2><h3 id="3-1层次结构"><a href="#3-1层次结构" class="headerlink" title="3.1层次结构"></a>3.1层次结构</h3><p>层次结构：一般来说，高层往底层走，存储设备变得更慢、更便宜和更大。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230903154018.png"></p>
<h3 id="3-2缓存"><a href="#3-2缓存" class="headerlink" title="3.2缓存"></a>3.2缓存</h3><p>高速缓存（cache）：一个小而快速的存储设备，作为存储在更大更慢的设备中的数据对象的缓冲区域。也就是层次结构中每一层都缓存来自较低一层的数据对象。<br>缓存（caching）：使用高速缓存的过程。<br>数据总以块大小为传送单元在第k层与第k+1层之间来回复制的。一般越小的存储设备的块就越小。因为离CPU较远的设备访问时间较长，所以使用更大的块。<br><strong>1.读取缓存</strong><br>第一种情况 <strong>缓存命中</strong>：程序需要的k+1层数据单元恰好在k层的一个块中。这样将会比从k+1层读取d更快。<br>第二种情况 <strong>缓存不命中</strong>：k层缓存从第k+1层缓存中读出包含d的块，如果k层的缓存已经满了，也就会覆盖现存的一个块。这个覆盖块的操作也被称为<strong>替换</strong>或<strong>驱逐</strong>。决定替换那个块是由缓存的替换策略来控制的。</p>
<p>缓存不命中的种类：<br>1 <strong>冷缓存&#x2F;强制性不命中</strong>：k层缓存是空的，那么无论访问任何数据对象都不会命中当出现了冷不命中缓存也就必须执行某个放置策略，确定把块放在哪里。<br>放置策略1 随机放块：很昂贵，定位起来代价很高<br>放置策略2 集中放块：限制了放块的地址，比如k+1层块0、4、8、12映射到k层的块0。<br>2 但这种放置策略也会引起一种不命中———<strong>冲突不命中</strong>：多个对象映射同一个块就会导致一直不命中。<br>3 <strong>容量不命中</strong>：缓存太小了不够放。</p>
<h2 id="4-高速缓存存储器"><a href="#4-高速缓存存储器" class="headerlink" title="4.高速缓存存储器"></a>4.高速缓存存储器</h2><p>C&#x3D;E*S*B<br>E:每组有几行<br>S：一共有多少组<br>B：一个块有几个字节</p>
<h3 id="4-1-通用的高速缓存存储器组织结构"><a href="#4-1-通用的高速缓存存储器组织结构" class="headerlink" title="4.1 通用的高速缓存存储器组织结构"></a>4.1 通用的高速缓存存储器组织结构</h3><p>高速缓存结构：有效位（是否包含有意义的信息）、标记位（唯一标识存储在这个高速缓存行的块），高速缓存块<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230904221056.png"></p>
<p>当加载指令指示从主存地址A读一个字，会从地址A发送到高速缓存这里查找，若高速缓存这里含有地址A这个字的副本则会直接返回给CPU。流程如下：组索引锁定位置，当有效位和标记位相匹配，则表明这个行里有包含的字。</p>
<h3 id="4-2-直接映射高速缓存"><a href="#4-2-直接映射高速缓存" class="headerlink" title="4.2 直接映射高速缓存"></a>4.2 直接映射高速缓存</h3><p>特点：每个组只有一行<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230904222138.png"><br>标记位是由tag+组号+块偏移，三个部分组成，检测时是先看有效位是否为1，1为有效，接着看tag只有tag号与请求相匹配才说明hit了，接着找到租号和块偏移来锁定块所在的位置。tag是用于检测的，就比如第一次请求地址的是0 也就是0000，block里面存放的是地址0-1，tag改为1，当请求地址是8也就是1000，尽管set同样是00但是也因为tag的不同(为1)，而无法命中</p>
<h3 id="4-3-组相联高速缓存"><a href="#4-3-组相联高速缓存" class="headerlink" title="4.3 组相联高速缓存"></a>4.3 组相联高速缓存</h3><p>特点：每个组都有多余一个高速缓存行，1&lt;E&lt;C&#x2F;B<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230905221941.png"><br>为什么需要块？由于空间局部性，当前地址被使用也很有可能使用相邻的地址，但是同时也会摊掉从内存调用的时间，因此块的设计需要保证大小合适，大小过大会令从内存调用到cache的时间会变多，但过小块的意义就不明显了。</p>
<h3 id="4-4-全相联高速缓存"><a href="#4-4-全相联高速缓存" class="headerlink" title="4.4 全相联高速缓存"></a>4.4 全相联高速缓存</h3><p>特点：只有一组 E&#x3D; C&#x2F;B，构建一个大的相连缓存很困难而且很贵，所以改换村只适合做小的高速缓存。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230905222354.png"><br>由于只有一组所以，地址只被划分了一个标记和一个块偏移</p>
<h3 id="4-5写相关的问题"><a href="#4-5写相关的问题" class="headerlink" title="4.5写相关的问题"></a>4.5写相关的问题</h3><p>如果想要写一个已经缓存的字，在高速缓存更新了他的w副本之后，该怎么才能更新到更低一层中的副本呢？<br>1.直写：<strong>立即</strong> 将w的高速缓存快写回到紧接着的第一层中。缺点：每次写都会引起总线能流量。<br>2.写回：只有当快要驱逐这个块的时候才把他写到紧接着的下一层中。缺点：增加了复杂性。<br>写分配&#x2F;非写分配<br>1.写分配：加载低一层的数据到高速缓存里，再由高速缓存分配给低一层。如果写不命中就会一个块从低一层传送到高速缓存里。写回一般是写分配。<br>2.非写分配：越过高速缓存，直接将字写入下一层中。直写一般是非写分配。</p>
<p>现代cache层次结构：会有多层的cache，L1 L2 L3 ，L3拥有8MB也就拥有更多的存储空间，当L1miss的时候就会向L2发送请求，L2miss的时候会向L3发送请求，当L3最后也miss就只能去内存里去找了</p>
<h1 id="07-链接"><a href="#07-链接" class="headerlink" title="07 链接"></a>07 链接</h1><p>链接（link）：将各种代码和数据片段收集并组合称为一个单一文件的过程<br>作用：<strong>可以执行分离编译</strong>，可以分解为小的单元，这样当修改时不需要全部编译一整个巨大的源文件。<br>连接的两个主要工作：符号解析（将每一个符号引用与一个符号定义相关联），重定位（将所有模块集合起来，进入单个可执行目标模块后，可以直接在系统上加载执行）</p>
<p>文件类型：<br>.o：可重定位目标模块，是汇编器的输出<br>.out：由汇编器生成的可执行目标文件<br>.so：共享库</p>
<h2 id="1-将程序翻译为目标可执行文件流程"><a href="#1-将程序翻译为目标可执行文件流程" class="headerlink" title="1.将程序翻译为目标可执行文件流程"></a>1.将程序翻译为目标可执行文件流程</h2><p>编译系统需要提供编译器驱动程序，调用语言预处理器，编译器，汇编器和链接器。<br>预处理器：就是将#include的内容插入进来以及去掉注释这些简单工作。</p>
<p>源程序（.c）——（预处理器）——&gt;ASCII码中间文件(.i)——（编译器）——&gt;ASCII汇编程序(.s)——（汇编器）——&gt;可重定位目标文件（.o）——(链接器)——&gt;可执行目标文件</p>
<h2 id="2-静态链接器"><a href="#2-静态链接器" class="headerlink" title="2.静态链接器"></a>2.静态链接器</h2><p>出现的问题：因为所有的程序在没有链接之前都是散的节，也就会出现指令在一节里，数据在一节里这种情况发生，为了解决这个问题链接器主要需要完成：符号解析+重定向。<br>符号解析：将每个符号引用对应一个符号定义<br>重定向：将这些符号从地址0开始对应一个内存的位置</p>
<h2 id="3-可重定位目标文件"><a href="#3-可重定位目标文件" class="headerlink" title="3.可重定位目标文件"></a>3.可重定位目标文件</h2><p>###3.1可执行的目标文件细节（ELF格式）<br>包含二进制代码以及数据，可以在编译时与其他可重定位目标文件合并，创造一个可执行的目标文件<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230910155612.png"><br>.text:已编译程序的机器代码<br>.rodata:只读数据，例如printf里面这些<br>.data:已初始化的全局变量和静态变量<br>.bss:未初始化的静态变量，以及初始化为0的全局变量或静态变量，不占用实际空间，只是一个占位符<br>.symtab:一个符号表，用于存放<strong>程序中定义和引用的函数和全局变量</strong>的信息<br>.rel.text:一个.text节中位置的列表，当链接器想要将这个目标文件与其他文件结合时需要修改位置信息。<br>.rel.data:被模块引用或定义的所有全局变量的重定位信息<br>.debug:调试符号表，定义的局部变量和类型定义<br>.line:原始c程序的行数和.text节中机器指令的映射<br>.strtab:一个字符串表，包括.symtab和.debug节中的符号表，以及节头部中的节名字。</p>
<p>###3.2符号和符号表<br>每个可重定位目标模块m都有一个符号表，包含m定义和引用符号的信息。共有3类<br>1.模块m定义并且能被其他模块引用的全局符号，全局链接器符号对应于非静态的C函数和全局变量。<br>2.其他模块定义并被模块m引用的全局符号，这些符号被称为外部符号，对应其他模块中定义的非静态的C函数和全局变量。<br>3.局部符号：带static属性的C函数和全局变量，不能被其他模块引用。<br>局部变量是归由堆栈处理的，链接器不管这个，但带上了static就得放在.data里了，就更像是一个全局变量。</p>
<p><strong>符号表：</strong><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230910162421.png"><br>name：字符串表的字节偏移，字符串的名字<br>value：符号的地址<br>size：目标的大小<br>type：要么是数据要么是函数<br>binding：表示本地还是全局<br>每个符号被分配到目标文件的某个节，有三个特殊的伪节在节头部表中没有条目：<br>ABS代表不该被重定位的符号<br>UNDEF：未定义的符号，在目标模块中引用但却在其他地方定义的符号<br>COMMON：未被分配位置的未初始化的数据目标。<br>COMMON与.bss，COMMON：未初始化的全局变量，.bss：未初始化的静态变量以及初始化为0的全局活静态变量。</p>
<pre><code>静态函数（extern):
1）静态函数在其他文件中科技定义形同的名字，不会发生冲突；
2）静态函数不能被其他文件所用；
3）静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。
加上了static的函数就有了一种私有的属性，别的模块时访问不到的
</code></pre>
<h2 id="4-符号解析"><a href="#4-符号解析" class="headerlink" title="4.符号解析"></a>4.符号解析</h2><p>小问题：调用全局符号的时候，可能会有同名符号，这种情况应该如何解决呢？</p>
<h3 id="4-1链接器如何解析多重定义的全局符号"><a href="#4-1链接器如何解析多重定义的全局符号" class="headerlink" title="4.1链接器如何解析多重定义的全局符号"></a>4.1链接器如何解析多重定义的全局符号</h3><p>强符号与弱符号<br>函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。<br>linux链接器处理多重定义的符号名的规则：<br>规则1 不允许有多个同名的强符号<br>规则2 若一个强符号和多个弱符号同名，则选择强符号<br>规则3 若有多个弱符号同名，则随便选一个。</p>
<h3 id="4-2与静态库链接"><a href="#4-2与静态库链接" class="headerlink" title="4.2与静态库链接"></a>4.2与静态库链接</h3><p>静态库：将所有相关的目标模块打包成为一个单独的文件。类似libm.a库中数学函数符号比如cos sin。<br>几种调用的方法<br>1.不使用动态库，编译器辨认出对标准函数的调用直接生成对应的代码。缺点非常不方便，添加一个标准函数时，需要一个新的编译器版本。<br>2.静态库全技能都放在一个单独的可重定位的目标模块中。将模块链接到可执行文件中。缺点：每个可执行文件都包含一份副本非常占地方。对标准函数改变需要重新编译整个源文件。</p>
<p>静态库的提出就是为了解决以上问题：<br>相关的函数可以被编译为独立的目标模块，然后封装为一个单独的静态库文件。然后应用程序指定单独的文件名字来使用这些库里的函数。在链接时，只复制被程序引用的目标模块，这样就减少了内存占用。<br>静态库以一种称为<strong>存档</strong>的特殊文件格式存放在磁盘中。存档文件是一组连接的可重定位目标文件的集合，一个头部来描述每个成员目标文件的大小和位置。存档文件名.a。</p>
<p>静态库链接：也就是用到静态库中什么函数，直接将可重定向文件地址拿出来 直接调用这个模块，这样就不需要将整个文件调用了。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230912220721.png"><br>静态库把所有函数的.o打成一个包，当别人调用的时候就把其中函数的.o文件单独提出来。</p>
<p>链接器所存的几个集合：可重定位目标文件E（集合中的文件会被合并起来形成可执行文件），一个未解析符号集合U（引用了但尚未定义的符号），前面输入文件中已定义的符号集合D。<br>当文件是存档文件时，如果该文件定义了一个符号来解析U的一个引用，那就可以将U中未定义符号加到E中（未定义符号可被解释了），D是记录前面文件中定义了哪些符号，如果后面文件有未定义的符号也会来D中查看</p>
<pre><code>gcc -static是为了让链接器生成一个可执行的目标文件
gcc foo.c libx.a libz.a foo.c调用静态库中的函数，这时就必须要保证.a之间顺序，就比如libz里有libx的函数，那么这时就会出error
</code></pre>
<h2 id="5-重定位"><a href="#5-重定位" class="headerlink" title="5.重定位"></a>5.重定位</h2><p>到这个阶段，完成了符号解析，链接器已经知道了他的输入目标模块中的代码节和数据节的确切大小，可以开始重定位了，重定位主要是负责，合并输入模块，并且为每个符号分配运行地址。主要两个步：重定位节和符号定位（将所有相同类型的节合并为一个新的节，将运行的内存地址分配给新的节），重定位节中的符号引用（为每个引用提供一个正确的运行地址）。</p>
<h3 id="5-1重定位条目"><a href="#5-1重定位条目" class="headerlink" title="5.1重定位条目"></a>5.1重定位条目</h3><p>当汇编器生成一个目标模块时，他并不知道数据代码放在内存什么位置，或不知道模块引用的任何外部定义的函数或者全局变量的位置就会使用重定位条目，告诉链接器合并时如何修改这个引用，代码重定位条目在.rel.text里，初始化数据的重定位条目在.rel.data中。格式如下：包括偏移，类型等</p>
<pre><code>typedef struct&#123;
    long offset;
    long type:32,
    symbol:32;
    long addend;
&#125;
</code></pre>
<h2 id="6-可执行目标文件"><a href="#6-可执行目标文件" class="headerlink" title="6.可执行目标文件"></a>6.可执行目标文件</h2><p>linux加载可执行目标文件prog：prog不是内置的shell命令，所以shell会认为prog是一个可执行的目标文件，通过调用某个驻留在储存器中的加载器来运行。加载器将可执行目标文件中的代码和数据从磁盘加载到内存里，然后跳转到程序的第一条指令或入口点来运行程序。<br>linux程序都有一个运行时的内存映像，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230918220159.png"></p>
<h2 id="7-动态链接共享库"><a href="#7-动态链接共享库" class="headerlink" title="7.动态链接共享库"></a>7.动态链接共享库</h2><p>7.1 动态链接库<br>静态库所存在的问题：<br>标准的IO函数例如printf和scanf，运行时，这些函数的代码会被复制到每个运行进程的文本断种，是对内存资源的浪费。共享库就是为了解决这样的问题被提出的。</p>
<p>共享库是一个目标模块，在运行或加载时可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程也被称为动态链接，动态库在linux中通常用.so来表示。<br><strong>共享方式</strong><br>1.一个库只有一个.so文件，所有引用该库的可执行目标文件共享这个.so文件的代码和数据，这样就不需要静态库复制和嵌入到可执行文件里了。<br>2.在内存中一个共享库的.text节的一个副本可以被不同正在运行的进程共享。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230918221135.png"><br>创建可执行文件时静态执行一些链接，加载时再动态完成链接过程。<br>可执行文件只保留一个动态链接器的路径名，相当于不整合在一起而是直接放一个链接去访问那个内存然后再调用过来。</p>
<p>7.2位置无关代码（PIC）<br>位置无关代码：可以使用直接加载而无需重定位的代码（PIC）</p>
<p>8.打桩<br>打桩：截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，可以实现追踪某个特殊库函数的调用次数，验证和追踪他的输入和输出值。</p>
<h1 id="08-异常控制流"><a href="#08-异常控制流" class="headerlink" title="08 异常控制流"></a>08 异常控制流</h1><h2 id="1异常"><a href="#1异常" class="headerlink" title="1异常"></a>1异常</h2><p>异常：控制流中的突变<br>事件：状态变化，例如系统定时器产生一个信号或者一个IO请求完成。<br>异常表：当处理器检测到有事件发生时，通过一张表进行间接过程调用，到一个专门处理这类事件的操作系统子程序（异常处理程序），对应异常会通过对应异常表里处理程序代码。</p>
<h3 id="1-1异常处理"><a href="#1-1异常处理" class="headerlink" title="1.1异常处理"></a>1.1异常处理</h3><p>系统启动时，操作系统分配和初始化一张称为异常表，在运行时处理器检测到一个事件，并且确定相应的异常号k，通过异常表调用对应的处理程序。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20230921215323.png"><br>异常类别：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231007112556.png"></p>
<ul>
<li>1.中断<br>中断是异步发生的，在完成中断处理程序之后，便会直接返回到下一条指令处，剩下的异常类型都是同步<font color=red>为什么陷阱是同步发生的?</font>发生的。</li>
<li>2.陷阱<br>陷阱是<em>有意的</em>异常时执行一条指令的结果。最广的用途在用户程序与内核之间提供一个像过程一样的接口，叫做系统调用。和中断一样返回到下一条语句。也就是正常现象。syscall就会导致一个到异常处理程序的陷阱。</li>
<li>3.故障<br>由错误情况引起，可能会被故障处理程序修正。故障处理程序根据故障是否能够修复，故障处理程序要么重新执行引起故障的指令，要么终止。</li>
<li>4.终止<br>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。</li>
</ul>
<h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2 进程"></a>2 进程</h2><p>进程的关键抽象：1 一个独立的逻辑控制流：好像程序独占处理器 2 私有的地址空间：好像程序独占使用内存系统</p>
<h3 id="2-1逻辑控制流"><a href="#2-1逻辑控制流" class="headerlink" title="2.1逻辑控制流"></a>2.1逻辑控制流</h3><p>单步调试程序就可以看到程序计数器PC的值，值唯一对应包含程序的可执行目标文件的指令。<br><strong>逻辑控制流&#x2F;逻辑流</strong>：PC值的序列<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231008204142.png"></p>
<h3 id="2-2并发流"><a href="#2-2并发流" class="headerlink" title="2.2并发流"></a>2.2并发流</h3><p>并发流：一个逻辑流的执行在时间上与另一个流重叠，多流并发执行的现象叫做<strong>并发</strong>，一个进程与其他进程轮流进行的概念叫做<strong>多任务</strong>，多任务也叫做<strong>时间分片</strong>。图8.12也是多任务，进程A有两个时间片。</p>
<h3 id="2-3上下文切换"><a href="#2-3上下文切换" class="headerlink" title="2.3上下文切换"></a>2.3上下文切换</h3><p>调度：在进程执行的某些时刻，内核可以决定抢占当前进程并<strong>重新开始</strong>一个先前被抢占了的进程，由调度器代码处理的。上下文切换就出现在例如内核调度一个进程的时候。保证运行的速度，例如在读取磁盘信息时就不需要长时间挂机等待，而是直接切回原来的进程里就好。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231008205545.png"></p>
<h2 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3 进程控制"></a>3 进程控制</h2><h3 id="3-1-获取进程ID"><a href="#3-1-获取进程ID" class="headerlink" title="3.1 获取进程ID"></a>3.1 获取进程ID</h3><p>getpid函数可以返回进程的PID</p>
<h3 id="3-2创建与终止进程"><a href="#3-2创建与终止进程" class="headerlink" title="3.2创建与终止进程"></a>3.2创建与终止进程</h3><p>进程的三种状态</p>
<ul>
<li>1.运行：CPU执行&#x2F;等待被执行&#x2F;被内核调度</li>
<li>2.停止：进程被挂起且不会被调度，当收到SIGSTOP信号时进程就会被停止，只有收到SIGCONT的信号进程才会再次开始运行</li>
<li>3.终止：1）收到一个信号，信号默认行为为终止进程 2）从主程序返回 3）调用exit函数</li>
</ul>
<p><strong>fork函数</strong>：</p>
<ul>
<li>1返回进程的PID，神奇之处在于调用一次但是会返回两次。一次在调用父进程中，一次在新创建的子进程中。父进程中fork返回子进程的PID，子进程中fork返回0，因为子进程PID总是非零。并且子进程与父进程居然是并发独立进程</li>
<li>2 内核可以以任意方式交替执行他们的逻辑控制流中的指令。</li>
<li>3 相同但是独立的地址空间，子父进程都有自己私有的地址空间。</li>
<li>4 共享文件</li>
</ul>
<p>进程图：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231008212008.png"><br>嵌套fork：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231008212126.png"></p>
<h3 id="3-3回收子进程"><a href="#3-3回收子进程" class="headerlink" title="3.3回收子进程"></a>3.3回收子进程</h3><p>当进程终止时，内核并不是立刻将他从系统中清除，知道被父进程<strong>回收</strong>，进程都会保持一种已终止的状态。一个终止但是还未被回收的进程也就是<strong>僵尸进程</strong><br>一个父进程终止后内核会安排init进程成为孤儿进程的养父（init进程是所有进程的祖先，肯定不会被终止，PID为1）<br><strong>waitpid</strong>：一个进程可以通过这个函数等待子进程终止或者停止。</p>
<ul>
<li>1 判定等待集合的成员</li>
<li>2 修改默认行为</li>
<li>3 检查已回收子进程的退出状态</li>
<li>4 错误条件</li>
</ul>
<h3 id="3-4进程休眠"><a href="#3-4进程休眠" class="headerlink" title="3.4进程休眠"></a>3.4进程休眠</h3><p><strong>sleep</strong>会挂起一段指定的时间，如果请求的时间量到了sleep返回0，否则返回还需要休眠的秒数。</p>
<h3 id="3-5加载并运行程序"><a href="#3-5加载并运行程序" class="headerlink" title="3.5加载并运行程序"></a>3.5加载并运行程序</h3><p><strong>execve</strong>在当前进程的上下文中加载并运行一个新程序<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231008213928.png"><br>execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。<br>argv+envp：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231008214526.png"><br>当main开始执行时，用户栈的组织结构下图所示。从栈底向栈顶来看首先是参数和环境字符串。栈往上紧随其后的是以 null结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串。首先是全局变量environ指向这些指针中的第一个envp[0]。紧随环境变量数组之后的是以null结尾的argv[0]数组，其中每个元素都指向栈中的一个参数字符串。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231008214656.png"><br><strong>操作环境数组：getenv</strong>返回值：环境变量的值（value），没找到返回NULL。<br><strong>添加环境数组：setenv</strong><br><strong>程序与进程</strong>：进程是执行中程序的一个具体的实例；程序总是运行在摸个进程的上下文中。</p>
<h2 id="4-信号"><a href="#4-信号" class="headerlink" title="4 信号"></a>4 信号</h2><p>linux信号：更高层的软件形式异常，允许进程和内核中断其他进程。例如除0内核就会发送SIGFPE（8）的一条非法指令。CTRL+C就会发送一个SIGINT信号（号码2），Linux信号表格如下<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231009201123.png"></p>
<ul>
<li>1 发送信号：内核通过更新目的的进程上下文的某个状态。</li>
<li>2 接收信号：目的进程被内核强制以某种方式对信号的发送做出反应时<br>待处理信号：一个发出但是没有被接收的信号，任何时刻，一种类型至多只会有一个待处理信号。</li>
</ul>
<h3 id="4-1发送信号"><a href="#4-1发送信号" class="headerlink" title="4.1发送信号"></a>4.1发送信号</h3><p>进程发送信号的机制都是基于<em>进程组</em>这个概念的。</p>
<ul>
<li>1 进程组<br>每一个进程都只属于一个进程组，进程组有一个正整数进程组ID来标识。<br><strong>getpgrp</strong>：返回当前进程的进程组ID，子进程与父进程的进程组ID是相同的<br><strong>setpgid</strong>：改变自己或者其他进程的进程组</li>
<li>2 <em>&#x2F;bin&#x2F;kill</em>程序来发送信号<br>&#x2F;bin&#x2F;kill可以向另外的进程发送任意的信号，&#x2F;bin&#x2F;kill -9 15213 也就是想15213进程发送9这个信号。若&#x2F;bin&#x2F;kill -9 -15213 则是向15213进程组的每个进程发送信号</li>
<li>3 从键盘发送信号<br>作业：表示对一条命令行求值而创建的进程，任何时刻至多只有一个前台作业活多个后台作业。<br>ls|grep ls就是前台作业，grep就是后台作业。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231009202548.png"></li>
<li>4 <em>kill</em>函数发送信号<br>kill会发送信号sig给进程所在进程组中的每个进程，包括调用进程自己。</li>
<li>5 <em>alarm</em>函数发送信号<br>可以安排内核在secs秒后发送一个SIGALRM信号给调用进程，向<strong>自己</strong>发送SIGALRM信号。</li>
</ul>
<h3 id="4-2接收信号"><a href="#4-2接收信号" class="headerlink" title="4.2接收信号"></a>4.2接收信号</h3><p>内核把进程p从内核模式切换到用户模式时，会检查有哪些待处理信号，内核选择集合中某个信号（通常为最小的）强制p接受k ，收到这个信号就会触发进程完成某个行为，完成后就传递回p的逻辑控制流的下一条指令。每个信号类型的默认行为是不同的。<br>sighandler_t signal(int signum,sighandler_t handler)<br>修改默认和信号signum相关的行为</p>
<ul>
<li>1 handler是SIG_IGN，直接忽略类型为signum的信号</li>
<li>2 handler是SIG_DFL，会恢复默认行为</li>
<li>3 handler是用户定义函数的地址，函数就称为信号处理程序<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231009205501.png"></li>
</ul>
<h3 id="4-3-阻塞和解除阻塞信号"><a href="#4-3-阻塞和解除阻塞信号" class="headerlink" title="4.3 阻塞和解除阻塞信号"></a>4.3 阻塞和解除阻塞信号</h3><p>隐式阻塞机制：若处理程序的过程中，又有另一个信号s传递过来则直到处理程序返回，s都会变成待处理而没有被接收<br>显式阻塞机制：可以使用<em>sigprocmask</em>明确地阻塞和解除阻塞选择的信号。</p>
<h3 id="4-4编写信号处理程序"><a href="#4-4编写信号处理程序" class="headerlink" title="4.4编写信号处理程序"></a>4.4编写信号处理程序</h3><ul>
<li>1 安全的信号处理 <ul>
<li>处理程序要尽可能简单</li>
<li>在处理程序只调用异步信号安全的函数<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231009210228.png"></li>
<li>保存恢复errno</li>
<li>阻塞所有信号，保护对共存全局数据结构的访问</li>
<li>用volatile声明全局变量。volatile保证编译器不要缓存这个变量，每次更新都重新从内存中读取</li>
<li>sig_atomic_t对这个类型的读写都会是连续的，防止共享情况下被中断。</li>
</ul>
</li>
</ul>
<h3 id="4-5非本地跳转"><a href="#4-5非本地跳转" class="headerlink" title="4.5非本地跳转"></a>4.5非本地跳转</h3><p>非本地跳转：控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。<em>setjmp</em>和<em>longjmp</em>setjmp在env缓冲区保存当前调用环境，longjmp从env缓冲区恢复调用环境。当遇到问题时，可以允许从一个深度嵌套的函数调用中立刻返回，当深度嵌套的函数调用中发现了一个错误情况，可以直接使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力解开调用栈。</p>
<h1 id="09-虚拟内存（VM）"><a href="#09-虚拟内存（VM）" class="headerlink" title="09 虚拟内存（VM）"></a>09 虚拟内存（VM）</h1><p>内存地方不够如果只用单纯那么一点内存的话空间用完就会占用其他进程的内存，这样就会引起很大的错误<br>虚拟内存的作用：<br>1）把主存看成是一个存储在磁盘上的地址空间的高速缓存，可以根据需要在磁盘和主存之间传送数据。<br>2）为每个进程提供一致的地址空间，简化了内存管理<br>3）保护每个进程的地址空间不被其他进程破坏</p>
<h2 id="1-物理和虚拟寻址"><a href="#1-物理和虚拟寻址" class="headerlink" title="1 物理和虚拟寻址"></a>1 物理和虚拟寻址</h2><p>物理寻址：<br>主存是由M个连续的字节大小的单位组成的数组，每个字节都有一个唯一的物理地址（PA）。CPU访问内存的方式也就是直接使用物理地址，这种方式也被称为<strong>物理寻址</strong>。<br>虚拟寻址：<br>CPU生成一个虚拟地址来访问主存，虚拟地址（VA）在送到内存之前转换为物理地址，虚拟地址转化为地址的操作也叫作<strong>地址翻译</strong>，CPU芯片上叫做内存管理单元（MMU）专门用来存放在主存的查询表来动态翻译虚拟地址。</p>
<h2 id="2-地址空间"><a href="#2-地址空间" class="headerlink" title="2 地址空间"></a>2 地址空间</h2><p>地址空间：非负整数地址的有序集合<br>线性地址空间：地址空间的整数是连续的<br>虚拟地址空间————物理地址空间</p>
<h2 id="3-虚拟内存作为缓存的工具"><a href="#3-虚拟内存作为缓存的工具" class="headerlink" title="3 虚拟内存作为缓存的工具"></a>3 虚拟内存作为缓存的工具</h2><p>虚拟页（VP）：虚拟内存会将磁盘上的数据分割为大小固定的块来处理传输，块就是虚拟页<br>物理页同理，物理页也被称为<strong>页帧</strong><br>三个种类：<br>未分配的：VM系统还未分配的页，不占用任何磁盘空间<br>缓存的：当前已缓存在物理内存中的已分配页<br>未缓存的：未缓存在物理内存中的已分配页<br><strong>被分配不代表以被缓存</strong><br>关系如下图：<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231010204047.png"></p>
<h3 id="3-1-DRAM缓存的组织结构"><a href="#3-1-DRAM缓存的组织结构" class="headerlink" title="3.1 DRAM缓存的组织结构"></a>3.1 DRAM缓存的组织结构</h3><p>SRAM缓存来代表L1、L2、L3高速缓存，DRAM代表虚拟内存系统的缓存，在主存中缓存虚拟页。虚拟页往往较大通常为4KB~2MB之间</p>
<h3 id="3-2页表"><a href="#3-2页表" class="headerlink" title="3.2页表"></a>3.2页表</h3><p>虚拟内存系统需要进行在DRAM中虚拟页的查找，若没有就需要判断虚拟页在磁盘的位置并且要找到虚拟页并将虚拟页从磁盘复制到DRAM中，替换虚拟页。<br><strong>页表</strong>就是用来将虚拟页映射到物理页，地址翻译硬件将虚拟地址转换为物理地址时，就会读取页表。页表也就是页表条目（PTE）的数组</p>
<p>页表的基本组织结构：<br>虚拟页（VP）缓存到物理地址，若已缓存有效位会设为1，并且物理地址处存放虚拟地址，页表处放置物理内存地址，3、6则是已经分配了但是还未缓存，也就是开头提到的未缓存的情况。有效位用于记录VP2是否被缓存到物理内存上了。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231010205115.png"><br>页命中：DRAM缓存命中。<br>缺页：DRAM如果缓存不命中<br>缺页替换：<br>选择一个页牺牲掉，然后替换掉VP4<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231010211635.png"><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231010211646.png"></p>
<p>VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。虚拟地址保证了每个进程可以共享一个副本，而不是每个 进程都包含C标准库的副本。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231010212750.png"></p>
<h2 id="4-地址翻译"><a href="#4-地址翻译" class="headerlink" title="4 地址翻译"></a>4 地址翻译</h2><p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231011203033.png"><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231011203107.png"><br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231011203141.png"><br>地址翻译：一个虚拟地址空间元素和一个物理地址空间中元素之间的映射。<br>虚拟地址&#x3D;虚拟页号+虚拟页偏移量<br>物理地址&#x3D;物理页号+物理页偏移量<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231011203519.png"><br><strong>页面命中步骤：</strong><br><strong>第 1 步：</strong> 处理器生成一个虚拟地址，并把它传送给 MMU。<br><strong>第 2 步：</strong> MMU 生成 PTE 地址，并从高速缓存&#x2F;主存请求得到它。（页表是在物理内存的一个数据结构，所以需要让MMU向PTE询问是否想要的虚拟地址在物理内存上）<br><strong>第 3 步：</strong> 高速缓存&#x2F;主存向 MMU 返回 PTE。<br><strong>第 4 步：</strong> MMU 构造物理地址，并把它传送给高速缓存&#x2F;主存。<br><strong>第 5 步：</strong> 高速缓存&#x2F;主存返回所请求的数据字给处理器。</p>
<p>页面未命中就是多了牺牲和加新页两个步骤。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231011204146.png"></p>
<h3 id="4-1结合高速缓存和虚拟内存"><a href="#4-1结合高速缓存和虚拟内存" class="headerlink" title="4.1结合高速缓存和虚拟内存"></a>4.1结合高速缓存和虚拟内存</h3><p>多了一层，如果PTE在L1高速缓存没有命中就向内存请求查找。</p>
<h3 id="4-2利用TLB加速地址翻译"><a href="#4-2利用TLB加速地址翻译" class="headerlink" title="4.2利用TLB加速地址翻译"></a>4.2利用TLB加速地址翻译</h3><p>TLB：翻译后备缓冲器，TLB是一个小的、虚拟寻址的缓存，每一行都保存着一个由单个PTE组成的块。</p>
<h3 id="4-3多级页表"><a href="#4-3多级页表" class="headerlink" title="4.3多级页表"></a>4.3多级页表</h3><p>如果我们有一个 32 位的地址空间、4KB 的页面和一个 4 字节的 PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中。（32-12+2），如果地址空间为64位的话就需要更大的空间，但是内存地址很宝贵怎么可能留这么大的页表放在内存里。所以我们使用页表来分散压力。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231011210758.png"><br>在使用过程中只需要以及页表在主存里就好。并且如果一级页表如果PTE是空的就不需要再创建二级页表了也就节约了很多的空间，正常来说4G空间也不可能全被页表占满，所以空间被大大节约了。<br><strong>使用k级页表的地址翻译：</strong> 所以虚拟地址都会比物理地址要大一些吧。<br><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231011211134.png"></p>
<h3 id="4-4Linux虚拟内存系统"><a href="#4-4Linux虚拟内存系统" class="headerlink" title="4.4Linux虚拟内存系统"></a>4.4Linux虚拟内存系统</h3><p><img src="https://cdn.jsdelivr.net/gh/caiji-QAQ/PICGO@master/20231012204126.png"></p>
<h2 id="5-内存映射"><a href="#5-内存映射" class="headerlink" title="5.内存映射"></a>5.内存映射</h2><p>内存映射：Linux通过将一个虚拟内存区域和一个磁盘上的对象关联起来已初始化这个虚拟内存区域的内容。<br>可以映射到两个类型对象：<br>1）Linux文件系统中的普通对象<br>2）匿名文件</p>
<h3 id="5-1映射对象"><a href="#5-1映射对象" class="headerlink" title="5.1映射对象"></a>5.1映射对象</h3><p>共享对象：进程将一个共享对象映射到虚拟地址空间的一个区域内，那么1）如果进行写操作，其他进程也是可见的，并且修改同时也会修改磁盘原始对象。 2）对于私有对象的区域做的操作，对于其他进程而言是不可见的，并且也不会反映在磁盘对象上<br>私有对象对进程写会有一个保护。<br>6.动态内存分配</p>

            </div>

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023/06/23/%E7%BB%8F%E6%B5%8E/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">经济学习</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/06/03/hexo%E5%91%BD%E4%BB%A4/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">hexo命令</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2024
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">caijiQAQ</a>
            
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>










<div class="post-scripts">
    
        
<script src="/js/post-helper.js"></script>

        
        
    
</div>



</body>
</html>
